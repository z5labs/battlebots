[{"body":" Context and Problem Statement As the project grows, architectural decisions are made that have long-term impacts on the system’s design, maintainability, and scalability. Without a structured way to document these decisions, we risk losing the context and rationale behind important choices, making it difficult for current and future team members to understand why certain approaches were taken.\nHow should we document architectural decisions in a way that is accessible, maintainable, and provides sufficient context for future reference?\nDecision Drivers Need for clear documentation of architectural decisions and their rationale Easy accessibility and searchability of past decisions Low barrier to entry for creating and maintaining decision records Integration with existing documentation workflow Version control friendly format Industry-standard approach that team members may already be familiar with Considered Options MADR (Markdown Architectural Decision Records) ADR using custom format Wiki-based documentation No formal ADR process Decision Outcome Chosen option: “MADR (Markdown Architectural Decision Records)”, because it provides a well-established, standardized format that is lightweight, version-controlled, and integrates seamlessly with our existing documentation structure. MADR 4.0.0 offers a clear template that captures all necessary information while remaining flexible enough for different types of decisions.\nConsequences Good, because MADR is a widely adopted standard with clear documentation and examples Good, because markdown files are easy to create, edit, and review through pull requests Good, because ADRs will be version-controlled alongside code, maintaining historical context Good, because the format is flexible enough to accommodate strategic, user-journey, and API design decisions Good, because team members can easily search and reference past decisions Neutral, because requires discipline to maintain and update ADR status as decisions evolve Bad, because team members need to learn and follow the MADR format conventions Confirmation Compliance will be confirmed through:\nCode reviews ensuring new architectural decisions are documented as ADRs ADRs are stored in docs/content/r\u0026d/adrs/ following the naming convention NNNN-title-with-dashes.md Regular reviews during architecture discussions to reference and update existing ADRs Pros and Cons of the Options MADR (Markdown Architectural Decision Records) MADR 4.0.0 is a standardized format for documenting architectural decisions using markdown.\nGood, because it’s a well-established standard with extensive documentation Good, because markdown is simple, portable, and version-control friendly Good, because it provides a clear structure while remaining flexible Good, because it integrates with static site generators and documentation tools Good, because it’s lightweight and doesn’t require special tools Neutral, because it requires some initial learning of the format Neutral, because maintaining consistency requires discipline ADR using custom format Create our own custom format for architectural decision records.\nGood, because we can tailor it exactly to our needs Bad, because it requires defining and maintaining our own standard Bad, because new team members won’t be familiar with the format Bad, because we lose the benefits of community knowledge and tooling Bad, because it may evolve inconsistently over time Wiki-based documentation Use a wiki system (like Confluence, Notion, or GitHub Wiki) to document decisions.\nGood, because wikis provide easy editing and hyperlinking Good, because some team members may be familiar with wiki tools Neutral, because it may or may not integrate with version control Bad, because content may not be version-controlled alongside code Bad, because it creates a separate system to maintain Bad, because it’s harder to review changes through standard PR process Bad, because portability and long-term accessibility may be concerns No formal ADR process Continue without a structured approach to documenting architectural decisions.\nGood, because it requires no additional overhead Bad, because context and rationale for decisions are lost over time Bad, because new team members struggle to understand why decisions were made Bad, because it leads to repeated discussions of previously settled questions Bad, because it makes it difficult to track when decisions should be revisited More Information MADR 4.0.0 specification: https://adr.github.io/madr/ ADRs will be categorized as: strategic, user-journey, or api-design ADR status values: proposed | accepted | rejected | deprecated | superseded by ADR-XXXX All ADRs are stored in docs/content/r\u0026d/adrs/ directory ","categories":"","description":"Adopt Markdown Architectural Decision Records (MADR) as the standard format for documenting architectural decisions in the project.\n","excerpt":"Adopt Markdown Architectural Decision Records (MADR) as the standard …","ref":"/battlebots/pr-preview/pr-142/rd/adrs/0001-use-madr-for-architecture-decision-records/","tags":"","title":"[0001] Use MADR for Architecture Decision Records"},{"body":"Overview The User Registration journey describes how new users create an account on the Battlebots platform. This is the first step in a user’s experience and sets the foundation for their identity, access control, and personalization throughout the platform. A smooth registration process is critical for user acquisition and reduces friction in getting started with battlebots.\nUser Personas Primary Persona: New Battlebot Developer\nDescription: A developer or team looking to deploy and compete with their battlebots in automated competitions Goals: Quickly create an account to start deploying battlebots Understand what access and capabilities they’ll have Feel confident their data and bots are secure Avoid creating yet another username/password combination Pain Points: Concern about granting OAuth permissions without understanding what data is accessed Unclear terms of service or data usage policies Friction if they need to create a GitHub account first (rare for developer audience) Journey Flow Diagram Use Mermaid syntax to create a flowchart representing the user journey:\ngraph TD A[User lands on platform] --\u003e B{Has account?} B --\u003e|Yes| C[Direct to login] B --\u003e|No| D[Click 'Sign in with GitHub'] D --\u003e E[Redirect to GitHub OAuth] E --\u003e F[User authorizes on GitHub] F --\u003e G{Authorization successful?} G --\u003e|No| H[Show error message] H --\u003e D G --\u003e|Yes| I[GitHub redirects with auth code] I --\u003e J[Exchange code for tokens] J --\u003e K[Fetch user profile from GitHub] K --\u003e L{User exists in system?} L --\u003e|Yes| M[Update user profile data] M --\u003e N[Create session] L --\u003e|No| O[Show terms of service] O --\u003e P{User accepts terms?} P --\u003e|No| Q[Cancel registration] Q --\u003e A P --\u003e|Yes| R[Create user account] R --\u003e S[Store GitHub ID and profile] S --\u003e N N --\u003e T[Redirect to onboarding/dashboard] Flow Narrative:\nEntry Point: User arrives at the platform homepage or a direct registration link Account Check: System determines if user already has an account; if yes, redirects to login flow GitHub OAuth Initiation: User clicks “Sign in with GitHub” button OAuth Redirect: System redirects user to GitHub’s OAuth authorization page with: Client ID for the Battlebots application Requested scopes (user:email, read:user) State parameter for CSRF protection Callback URL for return redirect GitHub Authorization: User reviews permissions and authorizes the Battlebots application on GitHub OAuth Callback: GitHub redirects back to Battlebots with: Authorization code (if successful) State parameter (for validation) Error code (if authorization failed or was cancelled) Token Exchange: System exchanges authorization code for access token via GitHub’s token endpoint Profile Fetch: System uses access token to fetch user’s GitHub profile including: GitHub ID (unique identifier) Username Email address (primary verified email) Name, avatar URL User Lookup: System checks if GitHub ID already exists in database New User Flow: If user doesn’t exist: Display terms of service acceptance screen Upon acceptance, create new user account with GitHub profile data Store GitHub ID as primary identifier Use GitHub username as default platform username (allow customization later) Existing User Flow: If user exists, update profile data with latest from GitHub Session Creation: Create authenticated session for user Redirect: Redirect to onboarding (new users) or dashboard (returning users) Persona-Specific Variations:\nNew Battlebot Developer: After accepting terms, redirected to onboarding flow to learn about deploying their first bot Platform Administrator: Automatically granted admin privileges if GitHub username is in configured admin list; has access to admin dashboard showing new registrations Requirements Access Control REQ-AC-001 Priority: P0 Description: GitHub user IDs must be unique and serve as the primary account identifier Rationale: Ensures each user has a distinct identity tied to their GitHub account. GitHub ID is immutable and prevents account conflicts even if users change their GitHub username. REQ-AC-002 Priority: P0 Description: Platform usernames default to GitHub username but must be unique across the platform Rationale: Provides a familiar starting point using GitHub identity while allowing customization. Prevents impersonation and confusion in competitions and leaderboards. REQ-AC-003 Priority: P0 Description: GitHub OAuth integration with proper scope requests (user:email, read:user) Rationale: Enables secure authentication without managing passwords. Requests minimal necessary permissions to access user identity and primary verified email. REQ-AC-004 Priority: P0 Description: CSRF protection using state parameter in OAuth flow Rationale: Prevents cross-site request forgery attacks during the OAuth authorization process, ensuring the callback is legitimate. REQ-AC-005 Priority: P0 Description: Store and validate GitHub access tokens securely with appropriate encryption Rationale: Protects user’s GitHub access tokens from unauthorized use and ensures compliance with OAuth security best practices. REQ-AC-006 Priority: P1 Description: Rate limiting on OAuth callback endpoint (max 10 requests per IP per minute) Rationale: Prevents abuse of the OAuth flow and protects against denial of service attacks on the authentication system. REQ-AC-007 Priority: P1 Description: Terms of service acceptance required before account creation Rationale: Ensures users explicitly consent to platform policies before gaining access, meeting legal requirements. Analytics REQ-AN-001 Priority: P0 Description: Track OAuth funnel metrics (GitHub button clicks, OAuth redirects, successful authorizations, account creations) Rationale: Provides visibility into conversion rates and identifies where users drop off in the OAuth flow, enabling optimization. REQ-AN-002 Priority: P0 Description: Track OAuth authorization failures and cancellations Rationale: Helps identify friction points in the GitHub authorization process and opportunities to improve messaging or user experience. REQ-AN-003 Priority: P1 Description: Track time-to-complete-registration (from initial button click to account creation) Rationale: Measures overall friction in the registration process and helps validate that OAuth provides a faster experience. REQ-AN-004 Priority: P1 Description: Track registration source (direct, referral, marketing campaign) Rationale: Helps understand which acquisition channels are most effective and informs marketing strategy. REQ-AN-005 Priority: P2 Description: Track terms of service acceptance vs. rejection rates Rationale: Identifies if terms of service are causing user drop-off and may need simplification or clarification. Success Metrics Success for the User Registration journey is measured by how efficiently and securely users can create accounts while maintaining platform integrity.\nQuantitative Metrics:\nOAuth Authorization Rate: Target 85%+ of users who initiate GitHub OAuth complete authorization Measures: Number of successful authorizations / Number of GitHub button clicks Registration Completion Rate: Target 90%+ of authorized users complete registration Measures: Number of completed registrations / Number of successful OAuth authorizations Time to Registration: Target median time \u003c 2 minutes Measures: Time between initial GitHub button click and account creation OAuth Error Rate: Target \u003c 5% of OAuth flows result in errors Measures: Number of OAuth errors / Number of OAuth attempts Terms Acceptance Rate: Target 95%+ of users accept terms of service Measures: Number of terms acceptances / Number of users shown terms Qualitative Metrics:\nUser Satisfaction: Target 4.5+ out of 5 rating on post-registration survey How it will be gathered: Optional survey after registration asking “How easy was the registration process?” GitHub OAuth Trust: Target 90%+ of users feel comfortable authorizing GitHub access How it will be gathered: Track authorization cancellation reasons via optional feedback prompt Related Documentation Existing ADRs:\n(No existing ADRs yet - this is a foundational journey) Required ADRs (Not Yet Created):\nGitHub OAuth Integration - Configuration of GitHub OAuth application, scope selection, and token management strategy Session Management - Decision on session approach (JWT, server-side sessions, refresh tokens) and expiration policies Data Privacy \u0026 Compliance - How user data from GitHub is stored, processed, and protected (GDPR, CCPA considerations) Rate Limiting Strategy - Approach for preventing OAuth abuse while not impacting legitimate users Username Customization Policy - Rules for when/how users can customize their username after initial GitHub-based registration Related User Journeys:\n(To be created) User Login via GitHub OAuth (To be created) User Session Management (To be created) User Onboarding (To be created) User Profile Management External Documentation:\nGitHub OAuth Documentation: https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps GitHub API - User endpoints: https://docs.github.com/en/rest/users/users Notes Future Enhancements:\nSocial proof during registration (e.g., “Join 10,000+ battlebot developers”) Support for additional OAuth providers (GitLab, Bitbucket) for users without GitHub accounts Ability to link multiple OAuth providers to a single account Username suggestions when preferred GitHub username is already taken Rich profile data import from GitHub (bio, location, organization) GitHub organization membership detection for team/enterprise features Progressive disclosure - collect minimal info upfront, gather more during onboarding Technical Considerations:\nOAuth state parameter must be cryptographically random and validated on callback GitHub access tokens should be encrypted at rest using strong encryption (AES-256) Consider token refresh strategy - GitHub OAuth tokens don’t expire but can be revoked Implement proper error handling for GitHub API rate limits Store registration attempt metadata for abuse detection Consider implementing a waiting room or queue during high-traffic periods Handle edge cases: user revokes GitHub app access, user deletes GitHub account, user changes GitHub email Implement proper logging for OAuth flow debugging without exposing sensitive tokens Consider PKCE (Proof Key for Code Exchange) extension for additional security Business Considerations:\nClear terms of service and privacy policy explaining what GitHub data is accessed and stored Transparency about GitHub permission scopes and why they’re needed Consider offering different account tiers (free vs paid) at registration Opportunity to capture user intent/interests during onboarding for personalization Legal requirements vary by jurisdiction - may need age verification or parental consent flows GitHub-only authentication may limit accessibility for users without GitHub accounts Battlebots platform targets developers, making GitHub auth a natural fit for the primary persona ","categories":"","description":"Defines the flow for new users to create an account and gain access to the Battlebots platform\n","excerpt":"Defines the flow for new users to create an account and gain access to …","ref":"/battlebots/pr-preview/pr-142/rd/user-journeys/0001-user-registration/","tags":"","title":"[0001] User Registration"},{"body":"User Journeys This section contains detailed user journey documentation that defines how users interact with the Battlebots platform. Each journey document includes:\nUser personas and their goals Step-by-step flow diagrams Technical requirements (access control, analytics, etc.) Success metrics These documents serve as the foundation for feature development and help ensure a consistent, user-centered experience.\n","categories":"","description":"Documentation of user flows and experiences for the Battlebots platform\n","excerpt":"Documentation of user flows and experiences for the Battlebots …","ref":"/battlebots/pr-preview/pr-142/rd/user-journeys/","tags":"","title":"User Journeys"},{"body":"Architecture Decision Records (ADRs) This section contains architectural decision records that document the key design choices made for the Battlebots platform. Each ADR follows the MADR 4.0.0 format and includes:\nContext and problem statement Decision drivers and constraints Considered options with pros and cons Decision outcome and rationale Consequences (positive and negative) Confirmation methods ADR Categories ADRs are classified into three categories:\nStrategic - High-level architectural decisions affecting the entire system (frameworks, authentication strategies, cross-cutting patterns). Use for foundational technology choices. User Journey - Decisions solving specific user journey problems. More tactical than strategic, but still architectural. Use when evaluating approaches to implement user-facing features. API Design - API endpoint implementation decisions (pagination, filtering, bulk operations). Use for significant API design trade-offs that warrant documentation. Status Values Each ADR has a status that reflects its current state:\nproposed - Decision is under consideration accepted - Decision has been approved and should be implemented rejected - Decision was considered but not approved deprecated - Decision is no longer relevant or has been superseded superseded by ADR-XXXX - Decision has been replaced by a newer ADR These records provide historical context for architectural decisions and help ensure consistency across the platform.\n","categories":"","description":"Documentation of architectural decisions made in the Battlebots platform using MADR 4.0.0 standard\n","excerpt":"Documentation of architectural decisions made in the Battlebots …","ref":"/battlebots/pr-preview/pr-142/rd/adrs/","tags":"","title":"Architecture Decision Records"},{"body":"Overview The POC User Journey describes the end-to-end flow for demonstrating the core BattleBots platform capabilities. This journey focuses on the minimal viable experience: two containerized bots deployed to Kubernetes engaging in a 1v1 battle. The POC validates the fundamental technical architecture and user experience before expanding to more complex features like tournaments, leaderboards, and advanced bot management.\nThis journey serves as the foundation for understanding the essential workflows and technical requirements that will inform all future platform development.\nUser Personas Primary Persona: POC Developer/Tester\nDescription: A developer or team member evaluating the BattleBots platform concept through a minimal proof of concept deployment Goals: Quickly implement and test a basic bot Deploy the POC environment to Kubernetes with minimal configuration Initiate and observe a 1v1 battle between two bots Validate that the core battle mechanics work as expected Identify technical and UX issues before full platform development Pain Points: Complex deployment processes that obscure core functionality Unclear bot implementation requirements or APIs Lack of visibility into battle state and progress Difficulty debugging when battles don’t start or fail mid-execution Journey Flow Diagram graph TD A[Start POC Journey] --\u003e B[Step 1: Implement Bot] B --\u003e C[Step 2: Deploy to Kubernetes] C --\u003e D[Step 3: Start Battle] D --\u003e E[Step 4: Monitor Battle] E --\u003e F{Battle Complete?} F --\u003e|No| E F --\u003e|Yes| G[Review Results] G --\u003e H[POC Complete] Step 1: User Implementing a Bot This step covers the developer experience of creating a bot that can participate in battles.\nsequenceDiagram participant Dev as Developer participant IDE as Development Environment participant SDK as Bot SDK/Framework participant Container as Container Image Dev-\u003e\u003eIDE: Create new bot project Dev-\u003e\u003eSDK: Import bot framework/SDK SDK--\u003e\u003eDev: Provide bot interface/template Dev-\u003e\u003eIDE: Implement bot logic Note over Dev,IDE: - Define bot behavior\u003cbr/\u003e- Implement decision logic\u003cbr/\u003e- Configure bot parameters Dev-\u003e\u003eIDE: Write Dockerfile Dev-\u003e\u003eContainer: Build container image Container--\u003e\u003eDev: Image build success Dev-\u003e\u003eContainer: Tag image for deployment Dev-\u003e\u003eContainer: Push to container registry Container--\u003e\u003eDev: Image ready for deployment Flow Narrative:\nProject Setup: Developer creates a new bot project using the provided bot SDK or framework Bot Interface: SDK provides the necessary interface, base classes, or templates that define how bots interact with the battle system Bot Implementation: Developer writes the bot’s decision logic including: Attack strategies Defense mechanisms Resource management State tracking Containerization: Developer creates a Dockerfile to package the bot as a container Build \u0026 Test: Developer builds the container image locally to verify it compiles and runs Registry Push: Developer pushes the container image to a registry accessible by the Kubernetes cluster Step 2: User Deploying the POC to Kubernetes This step covers deploying both the battle infrastructure and the two competing bots to a Kubernetes cluster.\nsequenceDiagram participant Dev as Developer participant CLI as kubectl/Deployment Tool participant K8s as Kubernetes Cluster participant Registry as Container Registry participant Battle as Battle Controller participant Bot1 as Bot 1 Pod participant Bot2 as Bot 2 Pod Dev-\u003e\u003eCLI: Apply battle controller manifests CLI-\u003e\u003eK8s: Create battle controller deployment K8s-\u003e\u003eRegistry: Pull battle controller image Registry--\u003e\u003eK8s: Return image K8s-\u003e\u003eBattle: Start battle controller Battle--\u003e\u003eK8s: Ready Dev-\u003e\u003eCLI: Apply bot 1 manifests CLI-\u003e\u003eK8s: Create bot 1 deployment K8s-\u003e\u003eRegistry: Pull bot 1 image Registry--\u003e\u003eK8s: Return image K8s-\u003e\u003eBot1: Start bot 1 pod Bot1--\u003e\u003eK8s: Ready Dev-\u003e\u003eCLI: Apply bot 2 manifests CLI-\u003e\u003eK8s: Create bot 2 deployment K8s-\u003e\u003eRegistry: Pull bot 2 image Registry--\u003e\u003eK8s: Return image K8s-\u003e\u003eBot2: Start bot 2 pod Bot2--\u003e\u003eK8s: Ready Dev-\u003e\u003eCLI: Verify all pods are running CLI-\u003e\u003eK8s: Get pod status K8s--\u003e\u003eDev: All pods ready Flow Narrative:\nBattle Controller Deployment: Developer deploys the battle controller service that will orchestrate the 1v1 battle Applies Kubernetes manifests (Deployment, Service, ConfigMap) Controller pulls from container registry Controller initializes and becomes ready Bot 1 Deployment: Developer deploys the first bot Applies bot 1 Kubernetes manifests Pod pulls bot container image Bot initializes and registers with battle controller Bot 2 Deployment: Developer deploys the second bot Applies bot 2 Kubernetes manifests Pod pulls bot container image Bot initializes and registers with battle controller Verification: Developer verifies all components are running Checks pod status Confirms bots are registered and ready Validates network connectivity between components Step 3: User Starting the Battle This step covers initiating the 1v1 battle between the two deployed bots.\nsequenceDiagram participant Dev as Developer participant CLI as kubectl/API Client participant Battle as Battle Controller participant Bot1 as Bot 1 participant Bot2 as Bot 2 Dev-\u003e\u003eCLI: Execute start battle command CLI-\u003e\u003eBattle: POST /battles (create battle) Battle-\u003e\u003eBattle: Validate bots are ready Battle-\u003e\u003eBattle: Initialize battle state Battle--\u003e\u003eCLI: Battle created (ID, status) CLI--\u003e\u003eDev: Battle ID: xyz123 Dev-\u003e\u003eCLI: Start battle xyz123 CLI-\u003e\u003eBattle: POST /battles/xyz123/start Battle-\u003e\u003eBot1: Send battle start notification Battle-\u003e\u003eBot2: Send battle start notification Bot1--\u003e\u003eBattle: Acknowledge ready Bot2--\u003e\u003eBattle: Acknowledge ready Battle-\u003e\u003eBattle: Begin battle loop Battle--\u003e\u003eCLI: Battle started CLI--\u003e\u003eDev: Battle is running Flow Narrative:\nBattle Creation: Developer initiates battle creation Executes command via kubectl, API, or CLI tool Specifies the two bots to participate Battle controller validates both bots are available Battle Initialization: Battle controller sets up the battle Creates battle instance with unique ID Initializes battle state (health, resources, turn counters) Establishes communication channels with both bots Bot Notification: Controller notifies bots that battle is starting Sends battle parameters and rules Bots acknowledge readiness Battle Commencement: Controller begins the battle loop Starts turn-based or real-time battle execution Returns battle ID and status to developer Confirmation: Developer receives confirmation that battle has started Can use battle ID to monitor progress Step 4: User Monitoring the Battle This step covers how the developer observes the battle as it progresses and reviews the final outcome.\nsequenceDiagram participant Dev as Developer participant CLI as kubectl/API Client participant Battle as Battle Controller participant Logs as Pod Logs participant Metrics as Metrics/Events loop Monitor Battle Progress Dev-\u003e\u003eCLI: Check battle status CLI-\u003e\u003eBattle: GET /battles/xyz123/status Battle--\u003e\u003eCLI: Return current state Note over Battle,CLI: - Bot health\u003cbr/\u003e- Turn number\u003cbr/\u003e- Recent actions\u003cbr/\u003e- Battle phase CLI--\u003e\u003eDev: Display battle state Dev-\u003e\u003eCLI: View battle events CLI-\u003e\u003eBattle: GET /battles/xyz123/events Battle--\u003e\u003eCLI: Return event stream CLI--\u003e\u003eDev: Display recent events Dev-\u003e\u003eCLI: Check bot logs CLI-\u003e\u003eLogs: kubectl logs bot-1 Logs--\u003e\u003eDev: Bot 1 log output CLI-\u003e\u003eLogs: kubectl logs bot-2 Logs--\u003e\u003eDev: Bot 2 log output Dev-\u003e\u003eCLI: View metrics CLI-\u003e\u003eMetrics: Query battle metrics Metrics--\u003e\u003eDev: Display metrics/graphs end Battle-\u003e\u003eBattle: Battle concludes Battle-\u003e\u003eMetrics: Record final results Battle--\u003e\u003eBattle: Update battle status to complete Dev-\u003e\u003eCLI: Check final battle status CLI-\u003e\u003eBattle: GET /battles/xyz123/status Battle--\u003e\u003eCLI: Return final results Note over Battle,CLI: - Winner\u003cbr/\u003e- Final health\u003cbr/\u003e- Total turns\u003cbr/\u003e- Battle duration\u003cbr/\u003e- Summary stats CLI--\u003e\u003eDev: Display battle results Flow Narrative:\nStatus Monitoring: Developer polls battle status Queries battle controller API for current state Views bot health, resources, and turn count Sees which bot is currently acting Event Streaming: Developer watches battle events in real-time Queries event stream from battle controller Views actions taken by each bot Sees damage dealt, resources consumed, state changes Log Inspection: Developer examines bot logs Uses kubectl to tail bot pod logs Sees bot decision-making process Identifies any errors or unexpected behavior Metrics Visualization: Developer views battle metrics Accesses metrics dashboard or API Views health over time, action frequency, etc. Monitors resource utilization of pods Battle Completion: Battle controller determines winner One bot’s health reaches zero, or Maximum turn limit reached, or Timeout occurs Results Review: Developer retrieves final battle results Queries final battle status Reviews winner, final statistics, and battle summary Exports or saves results for analysis Requirements Access Control REQ-AC-001 Priority: P1 Description: Battle controller must authenticate requests to start/stop battles Rationale: Prevents unauthorized users from interfering with running battles or starting battles without permission REQ-AC-002 Priority: P1 Description: Bot pods should run with minimal Kubernetes RBAC permissions Rationale: Limits potential damage from compromised or malicious bot code by restricting access to cluster resources REQ-AC-003 Priority: P2 Description: Battle status and logs should be accessible to the developer who initiated the battle Rationale: Ensures developers can monitor and debug their battles while maintaining privacy between different users Analytics REQ-AN-001 Priority: P0 Description: Track battle lifecycle events (created, started, completed, failed) Rationale: Essential for understanding battle flow, identifying failures, and measuring platform reliability REQ-AN-002 Priority: P0 Description: Record bot actions and decisions during battle Rationale: Enables replay, debugging, and analysis of bot behavior and battle dynamics REQ-AN-003 Priority: P1 Description: Track battle duration and turn counts Rationale: Helps identify performance issues, endless battles, and validates that battles complete in reasonable timeframes REQ-AN-004 Priority: P1 Description: Monitor resource utilization (CPU, memory) of bot pods during battles Rationale: Ensures bots don’t consume excessive resources and helps right-size pod resource requests/limits REQ-AN-005 Priority: P2 Description: Track deployment success rates and pod startup times Rationale: Identifies infrastructure issues and measures deployment reliability Success Metrics Success for the POC User Journey is measured by how effectively the proof of concept demonstrates core platform capabilities and validates technical feasibility.\nQuantitative Metrics:\nDeployment Success Rate: Target 95%+ of deployments complete without errors Measures: Number of successful deployments / Total deployment attempts Battle Completion Rate: Target 90%+ of started battles complete successfully Measures: Number of completed battles / Number of started battles Battle Duration: Target battles complete within 5 minutes Measures: Median time from battle start to completion Bot Responsiveness: Target \u003c1 second average response time per bot action Measures: Time between battle controller requesting action and bot responding Pod Startup Time: Target \u003c30 seconds for bot pods to become ready Measures: Time from pod creation to ready status Qualitative Metrics:\nPOC Validation Success: Target: POC successfully demonstrates core battle mechanics How it will be gathered: Stakeholder review and sign-off that POC meets objectives Developer Experience: Target: Developers can complete entire flow without external help How it will be gathered: Observation of POC execution, documentation review, developer feedback Related Documentation Existing ADRs:\n(No existing ADRs yet - this is the foundational POC journey) Required ADRs (Not Yet Created):\nBot SDK Architecture - Design of the bot interface, SDK, and communication protocol between bots and battle controller Battle Controller Design - Architecture of the battle controller, state management, and battle loop implementation Kubernetes Deployment Strategy - Pod specifications, resource limits, networking, and service discovery approach for POC Battle State Management - How battle state is stored, updated, and synchronized between components Container Registry Selection - Choice of container registry for bot images (Docker Hub, GCR, ECR, private registry) Monitoring and Observability - Approach for logging, metrics collection, and battle event streaming Bot Communication Protocol - API/protocol for battle controller to bot communication (REST, gRPC, WebSocket, message queue) Related User Journeys:\n(To be created) Bot Development and Testing (To be created) Multi-Bot Tournament (To be created) Battle Replay and Analysis (To be created) Bot Registration and Management API Documentation:\n(To be created) Battle Controller API specification (To be created) Bot SDK API reference Notes Future Enhancements:\nWeb-based battle visualization showing real-time battle state Battle replay functionality to review completed battles Support for more than 2 bots in a single battle (free-for-all or team modes) Automated bot testing framework for local development CI/CD pipeline for bot builds and deployments Persistent battle history and statistics database Leaderboard and ranking system based on battle results Bot versioning and rollback capabilities Pre-battle validation and simulation mode Resource limits and fairness controls to ensure balanced battles Technical Considerations:\nBattle controller should be stateless where possible, storing battle state externally (database, ConfigMap, CRD) Consider using Kubernetes Custom Resources (CRDs) to represent battles as native K8s objects Bot containers should have resource limits to prevent resource exhaustion Network policies may be needed to control communication between bots and battle controller Consider using a sidecar pattern for battle observability (logging, metrics collection) Battle timeout mechanism needed to prevent infinite battles Health checks and readiness probes essential for reliable pod lifecycle management Consider using Kubernetes Jobs or CronJobs for battle execution rather than long-running Deployments Event streaming could use Kubernetes events, or separate event bus (NATS, Kafka) Bot SDK should handle retries and graceful degradation for network issues Consider battle controller horizontal scaling for multiple concurrent battles in future Business Considerations:\nPOC success is critical for securing continued investment in platform development Simple, clear demonstration is more valuable than feature-rich complexity for POC POC should validate key technical risks: containerization, Kubernetes orchestration, bot communication Developer experience during POC will inform platform UX priorities POC timeline and resource requirements should be minimal to reduce cost and risk Successful POC demonstrates value proposition for target users (battlebot developers) POC should be easily repeatable and demonstrable to stakeholders Consider POC as foundation for future platform architecture decisions ","categories":"","description":"Documents the proof of concept for running a 1v1 battle between two containerized bots in Kubernetes\n","excerpt":"Documents the proof of concept for running a 1v1 battle between two …","ref":"/battlebots/pr-preview/pr-142/rd/user-journeys/0000-poc/","tags":"","title":"[0000] Proof of Concept - 1v1 Battle"},{"body":"Welcome! Battle Bots is a game in which you, the human, implement an autonomous “bot” to do battle with “bots” implemented by other humans.\nWhat is a Bot? A bot is a independent piece of software which is programmed to battle other bots by reacting to state updates (e.g. bot B moved to point A) and performing its own actions (e.g. fire missile at point A).\n","categories":"","description":"Battle Bots is a PVP game for autonomous players","excerpt":"Battle Bots is a PVP game for autonomous players","ref":"/battlebots/pr-preview/pr-142/","tags":"","title":"Battle Bots"},{"body":"R\u0026D Process The Research \u0026 Design process follows a structured workflow to ensure comprehensive analysis and documentation of user experiences, technical solutions, and implementation details.\nProcess Steps Document the User Journey\nCreate a user journey document for the specific user experience Include flow diagrams using Mermaid to visualize user interactions Define prioritized technical requirements (P0/P1/P2) Use the /new-user-journey command to create standardized documentation Design the Solution\nCreate an ADR that designs a solution to implement the user journey Identify and document: Additional ADRs needed for specific components APIs that need to be defined User interface flows (mobile, web, etc.) Data flow from user to end systems (database, notification system, etc.) Capture the complete system architecture and integration points Document Component ADRs\nCreate ADRs for specific technical components identified in the solution design Examples: authentication strategy, session management, account linking, data storage Use the /new-adr command to create standardized MADR 4.0.0 format documents Document technical decisions with context, considered options, and consequences Document Required APIs\nFor each API endpoint identified in the solution, create comprehensive API documentation Use the /new-api-doc command to create standardized documentation Include: Request/response schemas Authentication requirements Business logic flows (Mermaid diagrams) Error responses and status codes Example curl requests Document API Implementation\nFor each documented API, create an ADR describing the implementation approach Document technical decisions including: Programming language selection Framework and libraries Architecture patterns Testing strategy Example: ADR-0006 documents the tech stack for API development (z5labs/humus framework) Design User Interface\nCreate UI/UX designs for the user journey Ensure designs align with the documented user flows and API contracts Consider platform-specific requirements (mobile, web, desktop) Documentation Structure The R\u0026D documentation is organized into the following sections:\nUser Journeys - User experience flows with technical requirements ADRs - Architectural Decision Records documenting technical decisions APIs - REST API endpoint documentation with schemas and examples Analysis - Research and analysis of technologies and solutions ","categories":"","description":"","excerpt":"R\u0026D Process The Research \u0026 Design process follows a structured …","ref":"/battlebots/pr-preview/pr-142/rd/","tags":"","title":"Research \u0026 Design"},{"body":"","categories":"","description":"","excerpt":"","ref":"/battlebots/pr-preview/pr-142/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/battlebots/pr-preview/pr-142/tags/","tags":"","title":"Tags"}]