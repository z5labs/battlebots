[{"body":" Context and Problem Statement As the project grows, architectural decisions are made that have long-term impacts on the system’s design, maintainability, and scalability. Without a structured way to document these decisions, we risk losing the context and rationale behind important choices, making it difficult for current and future team members to understand why certain approaches were taken.\nHow should we document architectural decisions in a way that is accessible, maintainable, and provides sufficient context for future reference?\nDecision Drivers Need for clear documentation of architectural decisions and their rationale Easy accessibility and searchability of past decisions Low barrier to entry for creating and maintaining decision records Integration with existing documentation workflow Version control friendly format Industry-standard approach that team members may already be familiar with Considered Options MADR (Markdown Architectural Decision Records) ADR using custom format Wiki-based documentation No formal ADR process Decision Outcome Chosen option: “MADR (Markdown Architectural Decision Records)”, because it provides a well-established, standardized format that is lightweight, version-controlled, and integrates seamlessly with our existing documentation structure. MADR 4.0.0 offers a clear template that captures all necessary information while remaining flexible enough for different types of decisions.\nConsequences Good, because MADR is a widely adopted standard with clear documentation and examples Good, because markdown files are easy to create, edit, and review through pull requests Good, because ADRs will be version-controlled alongside code, maintaining historical context Good, because the format is flexible enough to accommodate strategic, user-journey, and API design decisions Good, because team members can easily search and reference past decisions Neutral, because requires discipline to maintain and update ADR status as decisions evolve Bad, because team members need to learn and follow the MADR format conventions Confirmation Compliance will be confirmed through:\nCode reviews ensuring new architectural decisions are documented as ADRs ADRs are stored in docs/content/r\u0026d/adrs/ following the naming convention NNNN-title-with-dashes.md Regular reviews during architecture discussions to reference and update existing ADRs Pros and Cons of the Options MADR (Markdown Architectural Decision Records) MADR 4.0.0 is a standardized format for documenting architectural decisions using markdown.\nGood, because it’s a well-established standard with extensive documentation Good, because markdown is simple, portable, and version-control friendly Good, because it provides a clear structure while remaining flexible Good, because it integrates with static site generators and documentation tools Good, because it’s lightweight and doesn’t require special tools Neutral, because it requires some initial learning of the format Neutral, because maintaining consistency requires discipline ADR using custom format Create our own custom format for architectural decision records.\nGood, because we can tailor it exactly to our needs Bad, because it requires defining and maintaining our own standard Bad, because new team members won’t be familiar with the format Bad, because we lose the benefits of community knowledge and tooling Bad, because it may evolve inconsistently over time Wiki-based documentation Use a wiki system (like Confluence, Notion, or GitHub Wiki) to document decisions.\nGood, because wikis provide easy editing and hyperlinking Good, because some team members may be familiar with wiki tools Neutral, because it may or may not integrate with version control Bad, because content may not be version-controlled alongside code Bad, because it creates a separate system to maintain Bad, because it’s harder to review changes through standard PR process Bad, because portability and long-term accessibility may be concerns No formal ADR process Continue without a structured approach to documenting architectural decisions.\nGood, because it requires no additional overhead Bad, because context and rationale for decisions are lost over time Bad, because new team members struggle to understand why decisions were made Bad, because it leads to repeated discussions of previously settled questions Bad, because it makes it difficult to track when decisions should be revisited More Information MADR 4.0.0 specification: https://adr.github.io/madr/ ADRs will be categorized as: strategic, user-journey, or api-design ADR status values: proposed | accepted | rejected | deprecated | superseded by ADR-XXXX All ADRs are stored in docs/content/r\u0026d/adrs/ directory ","categories":"","description":"Adopt Markdown Architectural Decision Records (MADR) as the standard format for documenting architectural decisions in the project.\n","excerpt":"Adopt Markdown Architectural Decision Records (MADR) as the standard …","ref":"/battlebots/pr-preview/pr-140/rd/adrs/0001-use-madr-for-architecture-decision-records/","tags":"","title":"[0001] Use MADR for Architecture Decision Records"},{"body":"Overview The User Registration journey describes how new users create an account on the Battlebots platform. This is the first step in a user’s experience and sets the foundation for their identity, access control, and personalization throughout the platform. A smooth registration process is critical for user acquisition and reduces friction in getting started with battlebots.\nUser Personas Primary Persona: New Battlebot Developer\nDescription: A developer or team looking to deploy and compete with their battlebots in automated competitions Goals: Quickly create an account to start deploying battlebots Understand what access and capabilities they’ll have Feel confident their data and bots are secure Avoid creating yet another username/password combination Pain Points: Concern about granting OAuth permissions without understanding what data is accessed Unclear terms of service or data usage policies Friction if they need to create a GitHub account first (rare for developer audience) Journey Flow Diagram Use Mermaid syntax to create a flowchart representing the user journey:\ngraph TD A[User lands on platform] --\u003e B{Has account?} B --\u003e|Yes| C[Direct to login] B --\u003e|No| D[Click 'Sign in with GitHub'] D --\u003e E[Redirect to GitHub OAuth] E --\u003e F[User authorizes on GitHub] F --\u003e G{Authorization successful?} G --\u003e|No| H[Show error message] H --\u003e D G --\u003e|Yes| I[GitHub redirects with auth code] I --\u003e J[Exchange code for tokens] J --\u003e K[Fetch user profile from GitHub] K --\u003e L{User exists in system?} L --\u003e|Yes| M[Update user profile data] M --\u003e N[Create session] L --\u003e|No| O[Show terms of service] O --\u003e P{User accepts terms?} P --\u003e|No| Q[Cancel registration] Q --\u003e A P --\u003e|Yes| R[Create user account] R --\u003e S[Store GitHub ID and profile] S --\u003e N N --\u003e T[Redirect to onboarding/dashboard] Flow Narrative:\nEntry Point: User arrives at the platform homepage or a direct registration link Account Check: System determines if user already has an account; if yes, redirects to login flow GitHub OAuth Initiation: User clicks “Sign in with GitHub” button OAuth Redirect: System redirects user to GitHub’s OAuth authorization page with: Client ID for the Battlebots application Requested scopes (user:email, read:user) State parameter for CSRF protection Callback URL for return redirect GitHub Authorization: User reviews permissions and authorizes the Battlebots application on GitHub OAuth Callback: GitHub redirects back to Battlebots with: Authorization code (if successful) State parameter (for validation) Error code (if authorization failed or was cancelled) Token Exchange: System exchanges authorization code for access token via GitHub’s token endpoint Profile Fetch: System uses access token to fetch user’s GitHub profile including: GitHub ID (unique identifier) Username Email address (primary verified email) Name, avatar URL User Lookup: System checks if GitHub ID already exists in database New User Flow: If user doesn’t exist: Display terms of service acceptance screen Upon acceptance, create new user account with GitHub profile data Store GitHub ID as primary identifier Use GitHub username as default platform username (allow customization later) Existing User Flow: If user exists, update profile data with latest from GitHub Session Creation: Create authenticated session for user Redirect: Redirect to onboarding (new users) or dashboard (returning users) Persona-Specific Variations:\nNew Battlebot Developer: After accepting terms, redirected to onboarding flow to learn about deploying their first bot Platform Administrator: Automatically granted admin privileges if GitHub username is in configured admin list; has access to admin dashboard showing new registrations Requirements Access Control REQ-AC-001 Priority: P0 Description: GitHub user IDs must be unique and serve as the primary account identifier Rationale: Ensures each user has a distinct identity tied to their GitHub account. GitHub ID is immutable and prevents account conflicts even if users change their GitHub username. REQ-AC-002 Priority: P0 Description: Platform usernames default to GitHub username but must be unique across the platform Rationale: Provides a familiar starting point using GitHub identity while allowing customization. Prevents impersonation and confusion in competitions and leaderboards. REQ-AC-003 Priority: P0 Description: GitHub OAuth integration with proper scope requests (user:email, read:user) Rationale: Enables secure authentication without managing passwords. Requests minimal necessary permissions to access user identity and primary verified email. REQ-AC-004 Priority: P0 Description: CSRF protection using state parameter in OAuth flow Rationale: Prevents cross-site request forgery attacks during the OAuth authorization process, ensuring the callback is legitimate. REQ-AC-005 Priority: P0 Description: Store and validate GitHub access tokens securely with appropriate encryption Rationale: Protects user’s GitHub access tokens from unauthorized use and ensures compliance with OAuth security best practices. REQ-AC-006 Priority: P1 Description: Rate limiting on OAuth callback endpoint (max 10 requests per IP per minute) Rationale: Prevents abuse of the OAuth flow and protects against denial of service attacks on the authentication system. REQ-AC-007 Priority: P1 Description: Terms of service acceptance required before account creation Rationale: Ensures users explicitly consent to platform policies before gaining access, meeting legal requirements. Analytics REQ-AN-001 Priority: P0 Description: Track OAuth funnel metrics (GitHub button clicks, OAuth redirects, successful authorizations, account creations) Rationale: Provides visibility into conversion rates and identifies where users drop off in the OAuth flow, enabling optimization. REQ-AN-002 Priority: P0 Description: Track OAuth authorization failures and cancellations Rationale: Helps identify friction points in the GitHub authorization process and opportunities to improve messaging or user experience. REQ-AN-003 Priority: P1 Description: Track time-to-complete-registration (from initial button click to account creation) Rationale: Measures overall friction in the registration process and helps validate that OAuth provides a faster experience. REQ-AN-004 Priority: P1 Description: Track registration source (direct, referral, marketing campaign) Rationale: Helps understand which acquisition channels are most effective and informs marketing strategy. REQ-AN-005 Priority: P2 Description: Track terms of service acceptance vs. rejection rates Rationale: Identifies if terms of service are causing user drop-off and may need simplification or clarification. Success Metrics Success for the User Registration journey is measured by how efficiently and securely users can create accounts while maintaining platform integrity.\nQuantitative Metrics:\nOAuth Authorization Rate: Target 85%+ of users who initiate GitHub OAuth complete authorization Measures: Number of successful authorizations / Number of GitHub button clicks Registration Completion Rate: Target 90%+ of authorized users complete registration Measures: Number of completed registrations / Number of successful OAuth authorizations Time to Registration: Target median time \u003c 2 minutes Measures: Time between initial GitHub button click and account creation OAuth Error Rate: Target \u003c 5% of OAuth flows result in errors Measures: Number of OAuth errors / Number of OAuth attempts Terms Acceptance Rate: Target 95%+ of users accept terms of service Measures: Number of terms acceptances / Number of users shown terms Qualitative Metrics:\nUser Satisfaction: Target 4.5+ out of 5 rating on post-registration survey How it will be gathered: Optional survey after registration asking “How easy was the registration process?” GitHub OAuth Trust: Target 90%+ of users feel comfortable authorizing GitHub access How it will be gathered: Track authorization cancellation reasons via optional feedback prompt Related Documentation Existing ADRs:\n(No existing ADRs yet - this is a foundational journey) Required ADRs (Not Yet Created):\nGitHub OAuth Integration - Configuration of GitHub OAuth application, scope selection, and token management strategy Session Management - Decision on session approach (JWT, server-side sessions, refresh tokens) and expiration policies Data Privacy \u0026 Compliance - How user data from GitHub is stored, processed, and protected (GDPR, CCPA considerations) Rate Limiting Strategy - Approach for preventing OAuth abuse while not impacting legitimate users Username Customization Policy - Rules for when/how users can customize their username after initial GitHub-based registration Related User Journeys:\n(To be created) User Login via GitHub OAuth (To be created) User Session Management (To be created) User Onboarding (To be created) User Profile Management External Documentation:\nGitHub OAuth Documentation: https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps GitHub API - User endpoints: https://docs.github.com/en/rest/users/users Notes Future Enhancements:\nSocial proof during registration (e.g., “Join 10,000+ battlebot developers”) Support for additional OAuth providers (GitLab, Bitbucket) for users without GitHub accounts Ability to link multiple OAuth providers to a single account Username suggestions when preferred GitHub username is already taken Rich profile data import from GitHub (bio, location, organization) GitHub organization membership detection for team/enterprise features Progressive disclosure - collect minimal info upfront, gather more during onboarding Technical Considerations:\nOAuth state parameter must be cryptographically random and validated on callback GitHub access tokens should be encrypted at rest using strong encryption (AES-256) Consider token refresh strategy - GitHub OAuth tokens don’t expire but can be revoked Implement proper error handling for GitHub API rate limits Store registration attempt metadata for abuse detection Consider implementing a waiting room or queue during high-traffic periods Handle edge cases: user revokes GitHub app access, user deletes GitHub account, user changes GitHub email Implement proper logging for OAuth flow debugging without exposing sensitive tokens Consider PKCE (Proof Key for Code Exchange) extension for additional security Business Considerations:\nClear terms of service and privacy policy explaining what GitHub data is accessed and stored Transparency about GitHub permission scopes and why they’re needed Consider offering different account tiers (free vs paid) at registration Opportunity to capture user intent/interests during onboarding for personalization Legal requirements vary by jurisdiction - may need age verification or parental consent flows GitHub-only authentication may limit accessibility for users without GitHub accounts Battlebots platform targets developers, making GitHub auth a natural fit for the primary persona ","categories":"","description":"Defines the flow for new users to create an account and gain access to the Battlebots platform\n","excerpt":"Defines the flow for new users to create an account and gain access to …","ref":"/battlebots/pr-preview/pr-140/rd/user-journeys/0001-user-registration/","tags":"","title":"[0001] User Registration"},{"body":"Overview This user journey describes how bot developers create and register autonomous bots on the Battle Bots platform. The journey covers the entire process from initial bot conception through registration and readiness for competition. This is a core user experience that enables the platform’s primary value proposition: enabling developers to compete with autonomous battlebots.\nUser Personas Primary Persona: Bot Developer\nDescription: A software developer (individual or team member) who wants to build and deploy an autonomous bot to compete in battles. They have programming experience and understand API integration concepts. Goals: Create a functional bot that can receive state updates and respond with actions Configure bot metadata and settings appropriately Successfully register the bot in the platform Have the bot ready to participate in battles Pain Points: Uncertainty about bot implementation requirements and specifications Difficulty understanding the bot communication protocol Lack of clear validation feedback during registration Unclear bot configuration options and their implications Secondary Persona: Team Leader\nDescription: A developer leading a team building bots, responsible for managing multiple bots and team access Goals: Streamline bot creation process for team members Understand bot ownership and access control Track which team members have created which bots Pain Points: Managing bot access and permissions across team members Tracking team’s bot portfolio Journey Flow Diagram graph TD A[Authenticated user] --\u003e B[Navigate to Create Bot page] B --\u003e C[Review bot requirements and specs] C --\u003e D[Enter bot metadata] D --\u003e E{Provide bot endpoint} E --\u003e|Webhook URL| F[Enter webhook URL] E --\u003e|Future: Other protocols| G[Configure other protocol] F --\u003e H[Configure bot settings] G --\u003e H H --\u003e I[Submit bot registration] I --\u003e J{Validation check} J --\u003e|Invalid| K[Display validation errors] K --\u003e D J --\u003e|Valid| L[Create bot record] L --\u003e M{Endpoint connectivity test} M --\u003e|Failed| N[Display connectivity error] N --\u003e F M --\u003e|Success| O[Bot registered successfully] O --\u003e P[Display bot details and credentials] P --\u003e Q[User implements bot logic] Q --\u003e R[Bot ready for battles] Flow Narrative:\nStarting Point: User is already authenticated (see User Journey 0001) and navigates to the bot creation interface\nReview Requirements: User reviews documentation about bot implementation requirements, including:\nCommunication protocol specifications Required API endpoints the bot must implement State update and action response format Rate limits and timeout requirements Enter Bot Metadata: User provides basic bot information:\nBot name (display name for the bot) Description (optional, helps other users understand the bot’s strategy) Bot version or identifier (for tracking iterations) Provide Bot Endpoint: User specifies how the platform will communicate with their bot:\nCurrent MVP: Webhook URL where the bot receives state updates Future: Support for gRPC, WebSocket, or other protocols Configure Bot Settings: User sets operational parameters:\nTimeout settings (how long to wait for bot responses) Opt-in/opt-out for specific battle types Public visibility settings (whether bot appears in public leaderboards) Submit Registration: Platform validates the submission:\nChecks required fields are present Validates URL format and accessibility Ensures bot name is unique for this user/team Verifies user hasn’t exceeded bot quota limits Validation Errors: If validation fails, user sees specific error messages and can correct issues\nEndpoint Connectivity Test: Platform performs a health check against the bot endpoint:\nSends a test request to verify the endpoint is reachable Validates the bot responds in the expected format Confirms response time is within acceptable limits Registration Success: Bot is created and user receives:\nBot unique identifier API credentials or tokens for authentication (if needed) Next steps guidance for implementation Link to bot management dashboard Implementation: User implements bot logic based on specifications and tests locally\nReady for Battle: Once implementation is complete, bot is ready to participate in battles\nPersona-Specific Variations:\nTeam Leader: May see additional options for assigning bot ownership or sharing access with team members Individual Developer: Streamlined flow without team management options Requirements Access Control REQ-AC-001 Priority: P0 Description: Only authenticated users can create bots Rationale: Bots must be associated with a user account for ownership, accountability, and access control. Prevents anonymous bot creation and abuse. REQ-AC-002 Priority: P0 Description: Users can only manage (view, edit, delete) their own bots Rationale: Ensures bot creators maintain exclusive control over their creations and prevents unauthorized modifications. REQ-AC-003 Priority: P1 Description: Bot creators can share bot management access with specific users or team members Rationale: Enables collaborative bot development within teams while maintaining security. REQ-AC-004 Priority: P2 Description: Bot creators can define read-only viewers for their bot’s configuration and performance Rationale: Allows sharing bot insights without granting modification privileges. Analytics REQ-AN-001 Priority: P0 Description: Track bot creation events including user ID, timestamp, and bot configuration Rationale: Essential for understanding platform adoption, identifying popular configuration patterns, and troubleshooting user issues. REQ-AN-002 Priority: P1 Description: Track bot registration validation failures and error types Rationale: Helps identify common user pain points in the registration process and areas where documentation or UX can be improved. REQ-AN-003 Priority: P1 Description: Track endpoint connectivity test results (success/failure rate) Rationale: Indicates user success in properly implementing bot endpoints and can highlight infrastructure or documentation issues. REQ-AN-004 Priority: P2 Description: Track time from bot registration to first battle participation Rationale: Measures the effectiveness of onboarding documentation and identifies friction in the journey from creation to active participation. Functionality REQ-FN-001 Priority: P0 Description: Platform must validate bot endpoint is reachable during registration Rationale: Prevents registration of non-functional bots and provides immediate feedback to users about configuration issues. REQ-FN-002 Priority: P0 Description: Platform must enforce unique bot names per user/team Rationale: Prevents confusion when managing multiple bots and ensures clear identification in battle contexts. REQ-FN-003 Priority: P1 Description: Platform must provide clear, actionable error messages for all validation failures Rationale: Reduces user frustration and support burden by enabling self-service problem resolution. REQ-FN-004 Priority: P1 Description: Platform must support bot metadata updates after creation Rationale: Allows users to iterate on bot configuration without recreating the entire bot, improving user experience. REQ-FN-005 Priority: P2 Description: Platform should provide a test/sandbox mode for validating bot implementation Rationale: Enables users to verify their bot works correctly before entering real battles, reducing failed battle experiences. Performance REQ-PF-001 Priority: P0 Description: Bot registration endpoint connectivity test must complete within 10 seconds Rationale: Provides timely feedback without causing user frustration during registration flow. REQ-PF-002 Priority: P1 Description: Bot creation API must respond within 2 seconds (excluding endpoint connectivity test) Rationale: Ensures responsive user experience during bot registration. Security REQ-SC-001 Priority: P0 Description: Platform must validate bot endpoint URLs to prevent SSRF attacks Rationale: Prevents malicious users from using bot registration to probe internal infrastructure. REQ-SC-002 Priority: P0 Description: Platform must enforce rate limits on bot creation per user Rationale: Prevents abuse and resource exhaustion from automated bot creation. REQ-SC-003 Priority: P1 Description: Platform should support HTTPS endpoints only for production bots Rationale: Ensures secure communication between platform and user bots, protecting sensitive battle state information. Success Metrics Quantitative Metrics:\nBot Creation Success Rate: Target 80%+ successful registrations on first attempt\nMeasures how many users successfully register a bot without validation errors Lower rates indicate UX or documentation issues Endpoint Validation Success Rate: Target 70%+ endpoints pass connectivity test on first try\nIndicates how well users understand bot implementation requirements Helps identify if specifications are clear enough Time to First Bot Creation: Target \u003c10 minutes from account creation\nMeasures onboarding effectiveness Indicates if the creation flow is intuitive Bot Creation to First Battle Time: Target \u003c24 hours median\nMeasures overall friction in getting started with the platform Includes both platform UX and user implementation time Qualitative Metrics:\nUser Satisfaction with Bot Creation Process: Target 4/5 rating\nGathered through post-creation survey Identifies pain points in the journey Documentation Clarity: Target 4/5 rating\nMeasured through survey question about bot specification documentation Indicates if users understand how to implement bots Related Documentation Existing ADRs:\nADR-0001: User Registration and Authentication Strategy - Defines authentication requirements that gate bot creation Required ADRs (Not Yet Created):\nBot Communication Protocol - Define how the platform communicates with user bots (webhook format, gRPC, WebSocket), request/response schemas, timeout handling, and retry logic. Critical for users to understand implementation requirements.\nBot Endpoint Validation Strategy - Define how the platform validates bot endpoints during registration, including security measures to prevent SSRF, acceptable response times, and validation criteria.\nBot Quota and Rate Limiting - Define limits on number of bots per user/team, bot creation rate limits, and how quotas scale with different user tiers or plans.\nBot Metadata and Configuration Schema - Define required and optional bot metadata fields, configuration options, validation rules, and data storage approach.\nBot Ownership and Access Control - Define ownership model for bots, team access patterns, permission levels, and how access is granted/revoked.\nRelated User Journeys:\n0001: User Registration - Users must complete registration before creating bots API Documentation:\nBot Registration API - Needs to be created to document POST /bots endpoint, request/response schemas, validation rules, and error responses Bot Management API - Needs to be created to document GET/PUT/DELETE /bots/{id} endpoints for managing registered bots Notes Future Enhancements:\nBot Templates: Provide starter templates in popular languages (Go, Python, JavaScript) to reduce implementation time Local Testing Tools: CLI tool or SDK that simulates battle state updates for local bot testing Bot Versioning: Support multiple versions of the same bot for A/B testing strategies Bot Cloning: Allow users to duplicate existing bots as starting points for variations Batch Bot Creation: API support for programmatically creating multiple bots Bot Import/Export: Allow users to export bot configuration and import it elsewhere Technical Considerations:\nBot endpoint validation must be performed asynchronously to avoid blocking the registration request if the user’s endpoint is slow Need to consider retry logic if bot endpoint is temporarily unavailable during registration Bot credentials (if generated) must be stored securely and transmitted only once Consider webhook signature verification to ensure battle state updates come from legitimate platform sources Database schema must support efficient querying of bots by owner, status, and creation date Consider implementing soft delete for bots to preserve historical battle data Business Considerations:\nBot creation is a key conversion metric - optimizing this flow impacts platform growth Free tier users may have limited bot quotas, paid tiers could offer more bots Bot creation is a gateway to monetization opportunities (premium features, higher quotas, advanced analytics) Public bot visibility could drive community engagement and platform discovery Bot creation friction directly impacts time-to-value for new users ","categories":"","description":"Defines the user journey for developers to create, configure, and register autonomous bots in the Battle Bots platform\n","excerpt":"Defines the user journey for developers to create, configure, and …","ref":"/battlebots/pr-preview/pr-140/rd/user-journeys/0002-creating-a-new-bot/","tags":"","title":"[0002] Creating a New Bot"},{"body":"User Journeys This section contains detailed user journey documentation that defines how users interact with the Battlebots platform. Each journey document includes:\nUser personas and their goals Step-by-step flow diagrams Technical requirements (access control, analytics, etc.) Success metrics These documents serve as the foundation for feature development and help ensure a consistent, user-centered experience.\n","categories":"","description":"Documentation of user flows and experiences for the Battlebots platform\n","excerpt":"Documentation of user flows and experiences for the Battlebots …","ref":"/battlebots/pr-preview/pr-140/rd/user-journeys/","tags":"","title":"User Journeys"},{"body":"Architecture Decision Records (ADRs) This section contains architectural decision records that document the key design choices made for the Battlebots platform. Each ADR follows the MADR 4.0.0 format and includes:\nContext and problem statement Decision drivers and constraints Considered options with pros and cons Decision outcome and rationale Consequences (positive and negative) Confirmation methods ADR Categories ADRs are classified into three categories:\nStrategic - High-level architectural decisions affecting the entire system (frameworks, authentication strategies, cross-cutting patterns). Use for foundational technology choices. User Journey - Decisions solving specific user journey problems. More tactical than strategic, but still architectural. Use when evaluating approaches to implement user-facing features. API Design - API endpoint implementation decisions (pagination, filtering, bulk operations). Use for significant API design trade-offs that warrant documentation. Status Values Each ADR has a status that reflects its current state:\nproposed - Decision is under consideration accepted - Decision has been approved and should be implemented rejected - Decision was considered but not approved deprecated - Decision is no longer relevant or has been superseded superseded by ADR-XXXX - Decision has been replaced by a newer ADR These records provide historical context for architectural decisions and help ensure consistency across the platform.\n","categories":"","description":"Documentation of architectural decisions made in the Battlebots platform using MADR 4.0.0 standard\n","excerpt":"Documentation of architectural decisions made in the Battlebots …","ref":"/battlebots/pr-preview/pr-140/rd/adrs/","tags":"","title":"Architecture Decision Records"},{"body":"Welcome! Battle Bots is a game in which you, the human, implement an autonomous “bot” to do battle with “bots” implemented by other humans.\nWhat is a Bot? A bot is a independent piece of software which is programmed to battle other bots by reacting to state updates (e.g. bot B moved to point A) and performing its own actions (e.g. fire missile at point A).\n","categories":"","description":"Battle Bots is a PVP game for autonomous players","excerpt":"Battle Bots is a PVP game for autonomous players","ref":"/battlebots/pr-preview/pr-140/","tags":"","title":"Battle Bots"},{"body":"R\u0026D Process The Research \u0026 Design process follows a structured workflow to ensure comprehensive analysis and documentation of user experiences, technical solutions, and implementation details.\nProcess Steps Document the User Journey\nCreate a user journey document for the specific user experience Include flow diagrams using Mermaid to visualize user interactions Define prioritized technical requirements (P0/P1/P2) Use the /new-user-journey command to create standardized documentation Design the Solution\nCreate an ADR that designs a solution to implement the user journey Identify and document: Additional ADRs needed for specific components APIs that need to be defined User interface flows (mobile, web, etc.) Data flow from user to end systems (database, notification system, etc.) Capture the complete system architecture and integration points Document Component ADRs\nCreate ADRs for specific technical components identified in the solution design Examples: authentication strategy, session management, account linking, data storage Use the /new-adr command to create standardized MADR 4.0.0 format documents Document technical decisions with context, considered options, and consequences Document Required APIs\nFor each API endpoint identified in the solution, create comprehensive API documentation Use the /new-api-doc command to create standardized documentation Include: Request/response schemas Authentication requirements Business logic flows (Mermaid diagrams) Error responses and status codes Example curl requests Document API Implementation\nFor each documented API, create an ADR describing the implementation approach Document technical decisions including: Programming language selection Framework and libraries Architecture patterns Testing strategy Example: ADR-0006 documents the tech stack for API development (z5labs/humus framework) Design User Interface\nCreate UI/UX designs for the user journey Ensure designs align with the documented user flows and API contracts Consider platform-specific requirements (mobile, web, desktop) Documentation Structure The R\u0026D documentation is organized into the following sections:\nUser Journeys - User experience flows with technical requirements ADRs - Architectural Decision Records documenting technical decisions APIs - REST API endpoint documentation with schemas and examples Analysis - Research and analysis of technologies and solutions ","categories":"","description":"","excerpt":"R\u0026D Process The Research \u0026 Design process follows a structured …","ref":"/battlebots/pr-preview/pr-140/rd/","tags":"","title":"Research \u0026 Design"},{"body":"","categories":"","description":"","excerpt":"","ref":"/battlebots/pr-preview/pr-140/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/battlebots/pr-preview/pr-140/tags/","tags":"","title":"Tags"}]