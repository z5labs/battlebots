<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Battle Bots on Battle Bots Documentation</title><link>https://z5labs.github.io/battlebots/pr-preview/pr-150/</link><description>Recent content in Battle Bots on Battle Bots Documentation</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 03 Dec 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://z5labs.github.io/battlebots/pr-preview/pr-150/index.xml" rel="self" type="application/rss+xml"/><item><title>[0001] Proof of Concept - 1v1 Battle</title><link>https://z5labs.github.io/battlebots/pr-preview/pr-150/research_and_development/user-journeys/0001-poc/</link><pubDate>Wed, 03 Dec 2025 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/pr-preview/pr-150/research_and_development/user-journeys/0001-poc/</guid><description>&lt;h2 id="idea"&gt;Idea&lt;/h2&gt;
&lt;p&gt;This proof of concept demonstrates containerized bots battling each other in a 1v1 match within a 2-dimensional space. To evaluate the optimal architecture for the final BattleBots platform, both a client/server implementation and a peer-to-peer implementation will be completed and compared.&lt;/p&gt;
&lt;h2 id="requirements"&gt;Requirements&lt;/h2&gt;
&lt;h3 id="clientserver-architecture"&gt;Client/Server Architecture&lt;/h3&gt;
&lt;p&gt;Implement a client/server architecture to evaluate its suitability for the final BattleBots platform.&lt;/p&gt;
&lt;h3 id="peer-to-peer-architecture"&gt;Peer-to-Peer Architecture&lt;/h3&gt;
&lt;p&gt;Implement a peer-to-peer architecture to compare against the client/server approach.&lt;/p&gt;</description></item><item><title>[0001] Use MADR for Architecture Decision Records</title><link>https://z5labs.github.io/battlebots/pr-preview/pr-150/research_and_development/adrs/0001-use-madr-for-architecture-decision-records/</link><pubDate>Sun, 02 Nov 2025 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/pr-preview/pr-150/research_and_development/adrs/0001-use-madr-for-architecture-decision-records/</guid><description>&lt;!--
ADR Categories:
- strategic: High-level architectural decisions (frameworks, auth strategies, cross-cutting patterns)
- user-journey: Solutions for specific user journey problems (feature implementation approaches)
- api-design: API endpoint design decisions (pagination, filtering, bulk operations)
--&gt;
&lt;h2 id="context-and-problem-statement"&gt;Context and Problem Statement&lt;/h2&gt;
&lt;p&gt;As the project grows, architectural decisions are made that have long-term impacts on the system&amp;rsquo;s design, maintainability, and scalability. Without a structured way to document these decisions, we risk losing the context and rationale behind important choices, making it difficult for current and future team members to understand why certain approaches were taken.&lt;/p&gt;</description></item><item><title>Loki: OTLP Integration</title><link>https://z5labs.github.io/battlebots/pr-preview/pr-150/research_and_development/analysis/observability/logs/loki/loki-otlp-integration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/pr-preview/pr-150/research_and_development/analysis/observability/logs/loki/loki-otlp-integration/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;Grafana Loki introduced native OpenTelemetry Protocol (OTLP) support in version 3.0, marking a significant advancement in how logs can be ingested into Loki. This native integration allows applications instrumented with OpenTelemetry to send logs directly to Loki using the standardized OTLP format, eliminating the need for format transformations and simplifying the observability pipeline.&lt;/p&gt;
&lt;p&gt;The native OTLP endpoint provides a fully OpenTelemetry-compliant ingestion path where logs sent in OTLP format are stored directly in Loki without requiring conversion to JSON or logfmt blobs. This approach leverages Loki&amp;rsquo;s structured metadata feature, which stores log attributes and other OpenTelemetry LogRecord fields separately from the log body itself. The result is a more intuitive query experience and better performance, as queries no longer need to parse JSON at runtime to access fields.&lt;/p&gt;</description></item><item><title>Loki: Overview</title><link>https://z5labs.github.io/battlebots/pr-preview/pr-150/research_and_development/analysis/observability/logs/loki/loki-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/pr-preview/pr-150/research_and_development/analysis/observability/logs/loki/loki-overview/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;Grafana Loki is a horizontally-scalable, highly-available, multi-tenant log aggregation system designed to be cost-effective and easy to operate. Inspired by Prometheus, Loki takes a fundamentally different approach to log storage compared to traditional systems like Elasticsearch.&lt;/p&gt;
&lt;p&gt;The core innovation of Loki is its index-free architecture: instead of indexing the full contents of log lines, Loki only indexes metadata labels for each log stream. This design dramatically reduces storage costs, memory requirements, and operational complexity while still enabling fast queries through label-based filtering and grep-style text search.&lt;/p&gt;</description></item><item><title>OpenTelemetry Collector Overview</title><link>https://z5labs.github.io/battlebots/pr-preview/pr-150/research_and_development/analysis/observability/otel-collector/opentelemetry-collector-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/pr-preview/pr-150/research_and_development/analysis/observability/otel-collector/opentelemetry-collector-overview/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;The OpenTelemetry Collector is a vendor-agnostic application that receives, processes, and exports telemetry data (traces, metrics, and logs). It serves as a centralized component in observability architectures, removing the need to run multiple agents or collectors for different telemetry formats and backends.&lt;/p&gt;
&lt;p&gt;The Collector supports open-source observability data formats including Jaeger, Prometheus, Fluent Bit, and others, while providing a unified approach to telemetry handling. It enables services to offload telemetry data quickly while the Collector handles retries, batching, encryption, and sensitive data filtering.&lt;/p&gt;</description></item><item><title>OpenTelemetry Collector: Logs Support</title><link>https://z5labs.github.io/battlebots/pr-preview/pr-150/research_and_development/analysis/observability/otel-collector/otel-collector-logs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/pr-preview/pr-150/research_and_development/analysis/observability/otel-collector/otel-collector-logs/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;The OpenTelemetry Collector provides comprehensive support for collecting, processing, and exporting log data from various sources to multiple backends. Unlike traditional logging agents that focus on specific formats or destinations, the Collector treats logs as first-class observability signals alongside metrics and traces.&lt;/p&gt;
&lt;p&gt;The Collector&amp;rsquo;s log support enables correlation between logs and traces through shared execution context (TraceId and SpanId), allowing unified observability across all three signal types. This correlation is particularly valuable for debugging complex distributed systems where understanding both the quantitative measurements and the detailed event context is essential.&lt;/p&gt;</description></item><item><title>OpenTelemetry Collector: Metrics Support</title><link>https://z5labs.github.io/battlebots/pr-preview/pr-150/research_and_development/analysis/observability/otel-collector/otel-collector-metrics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/pr-preview/pr-150/research_and_development/analysis/observability/otel-collector/otel-collector-metrics/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;The OpenTelemetry Collector provides comprehensive support for collecting, processing, and exporting metrics data from diverse sources to multiple backends. It serves as a bridge between different metrics ecosystems, enabling seamless integration of Prometheus metrics, host system metrics, and custom application metrics within a unified observability platform.&lt;/p&gt;
&lt;p&gt;The Collector&amp;rsquo;s metrics support emphasizes signal correlation—connecting metrics to traces through exemplars and enriching attributes via Baggage and Context. This enables powerful observability patterns such as jumping from a metric anomaly to related traces or finding metrics that explain slow trace spans.&lt;/p&gt;</description></item><item><title>OpenTelemetry Collector: Self-Monitoring</title><link>https://z5labs.github.io/battlebots/pr-preview/pr-150/research_and_development/analysis/observability/otel-collector/otel-collector-self-monitoring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/pr-preview/pr-150/research_and_development/analysis/observability/otel-collector/otel-collector-self-monitoring/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;The OpenTelemetry Collector is designed as an observable service itself, following the principle that observability infrastructure must be observable. The Collector exposes its own telemetry (metrics, logs, and optionally traces) to enable monitoring health, diagnosing issues, and optimizing performance.&lt;/p&gt;
&lt;p&gt;Self-monitoring is critical for production deployments—without visibility into the Collector&amp;rsquo;s operation, data loss or performance degradation can go undetected. The Collector provides built-in telemetry, diagnostic extensions, and debugging capabilities to ensure reliable operation at scale.&lt;/p&gt;</description></item><item><title>OpenTelemetry Collector: Traces Support</title><link>https://z5labs.github.io/battlebots/pr-preview/pr-150/research_and_development/analysis/observability/otel-collector/otel-collector-traces/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/pr-preview/pr-150/research_and_development/analysis/observability/otel-collector/otel-collector-traces/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;The OpenTelemetry Collector provides comprehensive support for distributed tracing, enabling collection, processing, and export of trace data from multiple sources to various backend systems. Distributed tracing tracks requests as they flow through distributed systems, providing visibility into service interactions, latency bottlenecks, and error propagation paths.&lt;/p&gt;
&lt;p&gt;The Collector acts as a central hub for trace data, accepting traces in multiple formats (OTLP, Jaeger, Zipkin), performing intelligent sampling decisions, and routing to multiple tracing backends simultaneously. This unified approach simplifies observability infrastructure while preserving the ability to use best-of-breed tools for different use cases.&lt;/p&gt;</description></item></channel></rss>