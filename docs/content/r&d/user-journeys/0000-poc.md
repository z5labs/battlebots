---
title: "[0000] Proof of Concept - 1v1 Battle"
description: >
    Documents the proof of concept for running a 1v1 battle between two containerized bots using podman-compose
type: docs
weight: -1
status: "draft"
date: 2025-12-03
owner: ""
stakeholders: []
---

## Overview

The POC User Journey describes the end-to-end flow for demonstrating the core BattleBots platform capabilities. This journey focuses on the minimal viable experience: two containerized bots running via podman-compose engaging in a 1v1 battle with a game server. The POC validates the fundamental technical architecture and user experience before expanding to more complex features like tournaments, leaderboards, and advanced bot management.

This journey serves as the foundation for understanding the essential workflows and technical requirements that will inform all future platform development.

## User Personas

**Primary Persona**: POC Developer/Tester
- **Description**: A developer or team member evaluating the BattleBots platform concept through a minimal proof of concept deployment
- **Goals**:
  - Quickly implement and test a basic bot
  - Deploy the POC environment using podman-compose with minimal configuration
  - Initiate and observe a 1v1 battle between two bots
  - Validate that the core battle mechanics work as expected
  - Monitor and analyze battle behavior using observability tools
  - Identify technical and UX issues before full platform development
- **Pain Points**:
  - Complex deployment processes that obscure core functionality
  - Unclear bot implementation requirements or APIs
  - Lack of visibility into battle state and progress
  - Difficulty debugging when battles don't start or fail mid-execution
  - Insufficient observability into container behavior and battle metrics

## Requirements

### Functionality

#### REQ-FN-001
- **Priority**: P0
- **Description**: Battle should be orchestrated via podman-compose configuration
- **Rationale**: Provides simple, declarative infrastructure that can be version controlled and easily shared

#### REQ-FN-002
- **Priority**: P0
- **Description**: Battle should automatically start once all bot containers are healthy
- **Rationale**: Eliminates manual intervention and provides seamless user experience from container startup to battle execution

#### REQ-FN-003
- **Priority**: P0
- **Description**: Entire POC should be runnable locally using podman-compose
- **Rationale**: Enables developers to test and validate the platform on any machine with podman installed, reducing infrastructure dependencies

#### REQ-FN-004
- **Priority**: P0
- **Description**: All bot containers and game server should communicate over a shared container network
- **Rationale**: Simplifies service discovery and enables direct communication between components without external networking configuration

#### REQ-FN-005
- **Priority**: P0
- **Description**: Battles should automatically end once one of the bots has been destroyed
- **Rationale**: Provides clear win condition and ensures battles terminate naturally without manual intervention

#### REQ-FN-006
- **Priority**: P0
- **Description**: All containers and resources should be cleaned up after battle completion
- **Rationale**: Prevents resource leaks and ensures repeatability for subsequent battle runs

#### REQ-FN-007
- **Priority**: P0
- **Description**: OpenTelemetry collector should be included in podman-compose setup to receive all observability signals
- **Rationale**: Provides unified observability collection point, decouples components from specific backend implementations, and enables flexible signal routing

#### REQ-FN-008
- **Priority**: P0
- **Description**: LGTM stack (Loki, Grafana, Tempo, Mimir) should be included in podman-compose setup
- **Rationale**: Provides comprehensive observability backend for logs, metrics, traces, and visualization essential for debugging and analysis

#### REQ-FN-009
- **Priority**: P0
- **Description**: Bot to game server communication should use gRPC protocol
- **Rationale**: Enables bot implementation in almost any programming language through gRPC's broad language support, lowering barriers to entry for bot developers

### Analytics

#### REQ-AN-001
- **Priority**: P0
- **Description**: All components should emit structured logs to OpenTelemetry collector, which forwards them to Loki
- **Rationale**: Centralized logging enables comprehensive debugging and battle event correlation across all containers while maintaining backend flexibility

#### REQ-AN-002
- **Priority**: P0
- **Description**: Record bot actions and decisions during battle
- **Rationale**: Enables replay, debugging, and analysis of bot behavior and battle dynamics

#### REQ-AN-003
- **Priority**: P0
- **Description**: Game server and bots should emit metrics to OpenTelemetry collector, which forwards them to Mimir
- **Rationale**: Enables real-time monitoring of battle performance, resource usage, and component health while decoupling from specific metrics backend

#### REQ-AN-004
- **Priority**: P1
- **Description**: Track battle duration and turn counts
- **Rationale**: Helps identify performance issues, endless battles, and validates that battles complete in reasonable timeframes

#### REQ-AN-005
- **Priority**: P1
- **Description**: Monitor resource utilization (CPU, memory) of bot containers during battles
- **Rationale**: Ensures bots don't consume excessive resources and helps identify resource optimization opportunities

#### REQ-AN-006
- **Priority**: P1
- **Description**: Game server should emit distributed traces to OpenTelemetry collector, which forwards them to Tempo
- **Rationale**: Enables detailed latency analysis and helps identify performance bottlenecks in battle execution flow while maintaining tracing backend flexibility

#### REQ-AN-007
- **Priority**: P0
- **Description**: Game server should log all battle events in sufficient detail to enable battle replay via Loki queries
- **Rationale**: Enables post-battle analysis, debugging, and replay functionality without requiring separate event storage infrastructure

## Success Metrics

Success for the POC User Journey is measured by how effectively the proof of concept demonstrates core platform capabilities and validates technical feasibility.

**Quantitative Metrics:**
- **Deployment Success Rate**: Target 95%+ of deployments complete without errors
  - Measures: Number of successful podman-compose deployments / Total deployment attempts
- **Battle Completion Rate**: Target 90%+ of started battles complete successfully
  - Measures: Number of completed battles / Number of started battles
- **Battle Duration**: Target battles complete within 5 minutes
  - Measures: Median time from battle start to completion
- **Bot Responsiveness**: Target <1 second average response time per bot action
  - Measures: Time between game server requesting action and bot responding
- **Container Startup Time**: Target <30 seconds for all containers to become healthy
  - Measures: Time from container creation to healthy status
- **Observability Coverage**: Target 100% of components emitting logs, metrics, and traces
  - Measures: Number of components with OpenTelemetry integration / Total number of components

**Qualitative Metrics:**
- **POC Validation Success**: Target: POC successfully demonstrates core battle mechanics
  - How it will be gathered: Stakeholder review and sign-off that POC meets objectives
- **Developer Experience**: Target: Developers can complete entire flow without external help
  - How it will be gathered: Observation of POC execution, documentation review, developer feedback

## Related Documentation

**Existing ADRs:**
- (No existing ADRs yet - this is the foundational POC journey)

**Required ADRs (Not Yet Created):**
- **Bot SDK Architecture** - Design of the bot interface, SDK, and gRPC service definitions for bot-to-game-server communication
- **Game Server Design** - Architecture of the game server, state management, battle loop implementation, and event logging schema
- **Container Orchestration Strategy** - podman-compose configuration, container resource limits, networking, and service discovery approach
- **Battle State Management** - How battle state is stored, updated, and synchronized between components
- **Container Registry Selection** - Choice of container registry for bot images (Docker Hub, Quay.io, local registry)
- **OpenTelemetry Collector Configuration** - OTel collector setup, receiver/processor/exporter pipeline configuration, and signal routing to LGTM stack
- **LGTM Stack Integration** - Configuration and integration approach for Loki, Grafana, Tempo, and Mimir receiving signals from OTel collector
- **gRPC API Design** - gRPC service definitions, message formats, and error handling for bot-to-game-server communication
- **Battle Event Logging Schema** - Structured log format for battle events enabling replay via Loki queries
- **Observability Schema** - Log structure, metric naming conventions, trace span design, and OpenTelemetry semantic conventions for consistent observability

**Related User Journeys:**
- (To be created) Bot Development and Testing
- (To be created) Multi-Bot Tournament
- (To be created) Battle Replay and Analysis
- (To be created) Bot Registration and Management

**API Documentation:**
- (To be created) Game Server gRPC API specification (protobuf definitions)
- (To be created) Bot SDK API reference with language-specific implementations
- (To be created) Battle event logging schema and replay query examples
- (To be created) OpenTelemetry collector configuration guide
- (To be created) LGTM Stack configuration guide

## Notes

**Future Enhancements:**
- Web-based battle visualization showing real-time battle state
- Interactive battle replay UI with timeline scrubbing (beyond basic Loki query-based replay)
- Support for more than 2 bots in a single battle (free-for-all or team modes)
- Bot SDK implementations in additional languages (Python, JavaScript, Rust, etc.)
- Automated bot testing framework for local development
- CI/CD pipeline for bot builds and deployments
- Persistent battle history and statistics database
- Leaderboard and ranking system based on battle results
- Bot versioning and rollback capabilities
- Pre-battle validation and simulation mode
- Resource limits and fairness controls to ensure balanced battles

**Technical Considerations:**
- Game server should be stateless where possible, storing battle state externally (database, volume mount, or in-memory with snapshots)
- Bot containers should have resource limits defined in podman-compose to prevent resource exhaustion
- Container network isolation ensures bots can only communicate with game server, not directly with each other
- gRPC communication requires HTTP/2 support; ensure container networking supports this protocol
- gRPC protobuf definitions should be versioned and shared across bot SDK implementations for compatibility
- All components should emit telemetry using OpenTelemetry SDKs for unified observability signal collection
- OpenTelemetry collector should be configured with receivers (OTLP, Prometheus), processors (batch, resource detection), and exporters (Loki, Tempo, Mimir)
- Battle event logs must include timestamps, battle ID, event type, and full event payload for effective replay
- Event logging schema should support chronological reconstruction of entire battle via LogQL queries
- Battle timeout mechanism needed to prevent infinite battles
- Health checks and startup probes essential for reliable container lifecycle management
- Bot SDK should handle gRPC retries, timeouts, and graceful degradation for network issues
- gRPC interceptors can be used for automatic OpenTelemetry trace propagation and logging
- LGTM stack containers should be configured with appropriate retention policies to manage disk usage
- Grafana dashboards should be pre-configured for battle metrics, container resources, and bot behavior
- Tempo trace sampling rate should balance observability depth with storage requirements
- OpenTelemetry collector enables future backend flexibility without changing component instrumentation
- Volume mounts may be needed for persistent metrics, logs, and OTel collector buffer
- Container startup order should ensure OpenTelemetry collector starts before application components, and LGTM stack before collector
- Network DNS resolution should allow services to discover each other by container name
- Components should use OpenTelemetry semantic conventions for consistent attribute naming across logs, metrics, and traces
- Consider gRPC streaming RPCs for real-time battle state updates vs polling-based approaches

**Business Considerations:**
- POC success is critical for securing continued investment in platform development
- Simple, clear demonstration is more valuable than feature-rich complexity for POC
- POC should validate key technical risks: containerization, gRPC bot communication, game server orchestration, OpenTelemetry integration, observability
- Developer experience during POC will inform platform UX priorities
- POC timeline and resource requirements should be minimal to reduce cost and risk
- Successful POC demonstrates value proposition for target users (battlebot developers)
- gRPC enables broader developer adoption by supporting multiple programming languages without platform lock-in
- Event-based replay via Loki queries eliminates need for separate event storage infrastructure, reducing complexity
- POC should be easily repeatable and demonstrable to stakeholders without requiring cloud infrastructure
- OpenTelemetry and LGTM stack integration demonstrates commitment to production-ready observability and vendor neutrality from the start
- OpenTelemetry adoption provides future flexibility to swap observability backends without code changes
- Consider POC as foundation for future platform architecture decisions
- Local-first development approach reduces infrastructure costs during development phase
