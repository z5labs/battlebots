[{"body":" Context and Problem Statement As the project grows, architectural decisions are made that have long-term impacts on the system’s design, maintainability, and scalability. Without a structured way to document these decisions, we risk losing the context and rationale behind important choices, making it difficult for current and future team members to understand why certain approaches were taken.\nHow should we document architectural decisions in a way that is accessible, maintainable, and provides sufficient context for future reference?\nDecision Drivers Need for clear documentation of architectural decisions and their rationale Easy accessibility and searchability of past decisions Low barrier to entry for creating and maintaining decision records Integration with existing documentation workflow Version control friendly format Industry-standard approach that team members may already be familiar with Considered Options MADR (Markdown Architectural Decision Records) ADR using custom format Wiki-based documentation No formal ADR process Decision Outcome Chosen option: “MADR (Markdown Architectural Decision Records)”, because it provides a well-established, standardized format that is lightweight, version-controlled, and integrates seamlessly with our existing documentation structure. MADR 4.0.0 offers a clear template that captures all necessary information while remaining flexible enough for different types of decisions.\nConsequences Good, because MADR is a widely adopted standard with clear documentation and examples Good, because markdown files are easy to create, edit, and review through pull requests Good, because ADRs will be version-controlled alongside code, maintaining historical context Good, because the format is flexible enough to accommodate strategic, user-journey, and API design decisions Good, because team members can easily search and reference past decisions Neutral, because requires discipline to maintain and update ADR status as decisions evolve Bad, because team members need to learn and follow the MADR format conventions Confirmation Compliance will be confirmed through:\nCode reviews ensuring new architectural decisions are documented as ADRs ADRs are stored in docs/content/r\u0026d/adrs/ following the naming convention NNNN-title-with-dashes.md Regular reviews during architecture discussions to reference and update existing ADRs Pros and Cons of the Options MADR (Markdown Architectural Decision Records) MADR 4.0.0 is a standardized format for documenting architectural decisions using markdown.\nGood, because it’s a well-established standard with extensive documentation Good, because markdown is simple, portable, and version-control friendly Good, because it provides a clear structure while remaining flexible Good, because it integrates with static site generators and documentation tools Good, because it’s lightweight and doesn’t require special tools Neutral, because it requires some initial learning of the format Neutral, because maintaining consistency requires discipline ADR using custom format Create our own custom format for architectural decision records.\nGood, because we can tailor it exactly to our needs Bad, because it requires defining and maintaining our own standard Bad, because new team members won’t be familiar with the format Bad, because we lose the benefits of community knowledge and tooling Bad, because it may evolve inconsistently over time Wiki-based documentation Use a wiki system (like Confluence, Notion, or GitHub Wiki) to document decisions.\nGood, because wikis provide easy editing and hyperlinking Good, because some team members may be familiar with wiki tools Neutral, because it may or may not integrate with version control Bad, because content may not be version-controlled alongside code Bad, because it creates a separate system to maintain Bad, because it’s harder to review changes through standard PR process Bad, because portability and long-term accessibility may be concerns No formal ADR process Continue without a structured approach to documenting architectural decisions.\nGood, because it requires no additional overhead Bad, because context and rationale for decisions are lost over time Bad, because new team members struggle to understand why decisions were made Bad, because it leads to repeated discussions of previously settled questions Bad, because it makes it difficult to track when decisions should be revisited More Information MADR 4.0.0 specification: https://adr.github.io/madr/ ADRs will be categorized as: strategic, user-journey, or api-design ADR status values: proposed | accepted | rejected | deprecated | superseded by ADR-XXXX All ADRs are stored in docs/content/r\u0026d/adrs/ directory ","categories":"","description":"Adopt Markdown Architectural Decision Records (MADR) as the standard format for documenting architectural decisions in the project.\n","excerpt":"Adopt Markdown Architectural Decision Records (MADR) as the standard …","ref":"/battlebots/rd/adrs/0001-use-madr-for-architecture-decision-records/","tags":"","title":"[0001] Use MADR for Architecture Decision Records"},{"body":"Overview The User Registration journey describes how new users create an account on the Battlebots platform. This is the first step in a user’s experience and sets the foundation for their identity, access control, and personalization throughout the platform. A smooth registration process is critical for user acquisition and reduces friction in getting started with battlebots.\nUser Personas Primary Persona: New Battlebot Developer\nDescription: A developer or team looking to deploy and compete with their battlebots in automated competitions Goals: Quickly create an account to start deploying battlebots Understand what access and capabilities they’ll have Feel confident their data and bots are secure Avoid creating yet another username/password combination Pain Points: Concern about granting OAuth permissions without understanding what data is accessed Unclear terms of service or data usage policies Friction if they need to create a GitHub account first (rare for developer audience) Journey Flow Diagram Use Mermaid syntax to create a flowchart representing the user journey:\ngraph TD A[User lands on platform] --\u003e B{Has account?} B --\u003e|Yes| C[Direct to login] B --\u003e|No| D[Click 'Sign in with GitHub'] D --\u003e E[Redirect to GitHub OAuth] E --\u003e F[User authorizes on GitHub] F --\u003e G{Authorization successful?} G --\u003e|No| H[Show error message] H --\u003e D G --\u003e|Yes| I[GitHub redirects with auth code] I --\u003e J[Exchange code for tokens] J --\u003e K[Fetch user profile from GitHub] K --\u003e L{User exists in system?} L --\u003e|Yes| M[Update user profile data] M --\u003e N[Create session] L --\u003e|No| O[Show terms of service] O --\u003e P{User accepts terms?} P --\u003e|No| Q[Cancel registration] Q --\u003e A P --\u003e|Yes| R[Create user account] R --\u003e S[Store GitHub ID and profile] S --\u003e N N --\u003e T[Redirect to onboarding/dashboard] Flow Narrative:\nEntry Point: User arrives at the platform homepage or a direct registration link Account Check: System determines if user already has an account; if yes, redirects to login flow GitHub OAuth Initiation: User clicks “Sign in with GitHub” button OAuth Redirect: System redirects user to GitHub’s OAuth authorization page with: Client ID for the Battlebots application Requested scopes (user:email, read:user) State parameter for CSRF protection Callback URL for return redirect GitHub Authorization: User reviews permissions and authorizes the Battlebots application on GitHub OAuth Callback: GitHub redirects back to Battlebots with: Authorization code (if successful) State parameter (for validation) Error code (if authorization failed or was cancelled) Token Exchange: System exchanges authorization code for access token via GitHub’s token endpoint Profile Fetch: System uses access token to fetch user’s GitHub profile including: GitHub ID (unique identifier) Username Email address (primary verified email) Name, avatar URL User Lookup: System checks if GitHub ID already exists in database New User Flow: If user doesn’t exist: Display terms of service acceptance screen Upon acceptance, create new user account with GitHub profile data Store GitHub ID as primary identifier Use GitHub username as default platform username (allow customization later) Existing User Flow: If user exists, update profile data with latest from GitHub Session Creation: Create authenticated session for user Redirect: Redirect to onboarding (new users) or dashboard (returning users) Persona-Specific Variations:\nNew Battlebot Developer: After accepting terms, redirected to onboarding flow to learn about deploying their first bot Platform Administrator: Automatically granted admin privileges if GitHub username is in configured admin list; has access to admin dashboard showing new registrations Requirements Access Control REQ-AC-001 Priority: P0 Description: GitHub user IDs must be unique and serve as the primary account identifier Rationale: Ensures each user has a distinct identity tied to their GitHub account. GitHub ID is immutable and prevents account conflicts even if users change their GitHub username. REQ-AC-002 Priority: P0 Description: Platform usernames default to GitHub username but must be unique across the platform Rationale: Provides a familiar starting point using GitHub identity while allowing customization. Prevents impersonation and confusion in competitions and leaderboards. REQ-AC-003 Priority: P0 Description: GitHub OAuth integration with proper scope requests (user:email, read:user) Rationale: Enables secure authentication without managing passwords. Requests minimal necessary permissions to access user identity and primary verified email. REQ-AC-004 Priority: P0 Description: CSRF protection using state parameter in OAuth flow Rationale: Prevents cross-site request forgery attacks during the OAuth authorization process, ensuring the callback is legitimate. REQ-AC-005 Priority: P0 Description: Store and validate GitHub access tokens securely with appropriate encryption Rationale: Protects user’s GitHub access tokens from unauthorized use and ensures compliance with OAuth security best practices. REQ-AC-006 Priority: P1 Description: Rate limiting on OAuth callback endpoint (max 10 requests per IP per minute) Rationale: Prevents abuse of the OAuth flow and protects against denial of service attacks on the authentication system. REQ-AC-007 Priority: P1 Description: Terms of service acceptance required before account creation Rationale: Ensures users explicitly consent to platform policies before gaining access, meeting legal requirements. Analytics REQ-AN-001 Priority: P0 Description: Track OAuth funnel metrics (GitHub button clicks, OAuth redirects, successful authorizations, account creations) Rationale: Provides visibility into conversion rates and identifies where users drop off in the OAuth flow, enabling optimization. REQ-AN-002 Priority: P0 Description: Track OAuth authorization failures and cancellations Rationale: Helps identify friction points in the GitHub authorization process and opportunities to improve messaging or user experience. REQ-AN-003 Priority: P1 Description: Track time-to-complete-registration (from initial button click to account creation) Rationale: Measures overall friction in the registration process and helps validate that OAuth provides a faster experience. REQ-AN-004 Priority: P1 Description: Track registration source (direct, referral, marketing campaign) Rationale: Helps understand which acquisition channels are most effective and informs marketing strategy. REQ-AN-005 Priority: P2 Description: Track terms of service acceptance vs. rejection rates Rationale: Identifies if terms of service are causing user drop-off and may need simplification or clarification. Success Metrics Success for the User Registration journey is measured by how efficiently and securely users can create accounts while maintaining platform integrity.\nQuantitative Metrics:\nOAuth Authorization Rate: Target 85%+ of users who initiate GitHub OAuth complete authorization Measures: Number of successful authorizations / Number of GitHub button clicks Registration Completion Rate: Target 90%+ of authorized users complete registration Measures: Number of completed registrations / Number of successful OAuth authorizations Time to Registration: Target median time \u003c 2 minutes Measures: Time between initial GitHub button click and account creation OAuth Error Rate: Target \u003c 5% of OAuth flows result in errors Measures: Number of OAuth errors / Number of OAuth attempts Terms Acceptance Rate: Target 95%+ of users accept terms of service Measures: Number of terms acceptances / Number of users shown terms Qualitative Metrics:\nUser Satisfaction: Target 4.5+ out of 5 rating on post-registration survey How it will be gathered: Optional survey after registration asking “How easy was the registration process?” GitHub OAuth Trust: Target 90%+ of users feel comfortable authorizing GitHub access How it will be gathered: Track authorization cancellation reasons via optional feedback prompt Related Documentation Existing ADRs:\n(No existing ADRs yet - this is a foundational journey) Required ADRs (Not Yet Created):\nGitHub OAuth Integration - Configuration of GitHub OAuth application, scope selection, and token management strategy Session Management - Decision on session approach (JWT, server-side sessions, refresh tokens) and expiration policies Data Privacy \u0026 Compliance - How user data from GitHub is stored, processed, and protected (GDPR, CCPA considerations) Rate Limiting Strategy - Approach for preventing OAuth abuse while not impacting legitimate users Username Customization Policy - Rules for when/how users can customize their username after initial GitHub-based registration Related User Journeys:\n(To be created) User Login via GitHub OAuth (To be created) User Session Management (To be created) User Onboarding (To be created) User Profile Management External Documentation:\nGitHub OAuth Documentation: https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps GitHub API - User endpoints: https://docs.github.com/en/rest/users/users Notes Future Enhancements:\nSocial proof during registration (e.g., “Join 10,000+ battlebot developers”) Support for additional OAuth providers (GitLab, Bitbucket) for users without GitHub accounts Ability to link multiple OAuth providers to a single account Username suggestions when preferred GitHub username is already taken Rich profile data import from GitHub (bio, location, organization) GitHub organization membership detection for team/enterprise features Progressive disclosure - collect minimal info upfront, gather more during onboarding Technical Considerations:\nOAuth state parameter must be cryptographically random and validated on callback GitHub access tokens should be encrypted at rest using strong encryption (AES-256) Consider token refresh strategy - GitHub OAuth tokens don’t expire but can be revoked Implement proper error handling for GitHub API rate limits Store registration attempt metadata for abuse detection Consider implementing a waiting room or queue during high-traffic periods Handle edge cases: user revokes GitHub app access, user deletes GitHub account, user changes GitHub email Implement proper logging for OAuth flow debugging without exposing sensitive tokens Consider PKCE (Proof Key for Code Exchange) extension for additional security Business Considerations:\nClear terms of service and privacy policy explaining what GitHub data is accessed and stored Transparency about GitHub permission scopes and why they’re needed Consider offering different account tiers (free vs paid) at registration Opportunity to capture user intent/interests during onboarding for personalization Legal requirements vary by jurisdiction - may need age verification or parental consent flows GitHub-only authentication may limit accessibility for users without GitHub accounts Battlebots platform targets developers, making GitHub auth a natural fit for the primary persona ","categories":"","description":"Defines the flow for new users to create an account and gain access to the Battlebots platform\n","excerpt":"Defines the flow for new users to create an account and gain access to …","ref":"/battlebots/rd/user-journeys/0001-user-registration/","tags":"","title":"[0001] User Registration"},{"body":"User Journeys This section contains detailed user journey documentation that defines how users interact with the Battlebots platform. Each journey document includes:\nUser personas and their goals Step-by-step flow diagrams Technical requirements (access control, analytics, etc.) Success metrics These documents serve as the foundation for feature development and help ensure a consistent, user-centered experience.\n","categories":"","description":"Documentation of user flows and experiences for the Battlebots platform\n","excerpt":"Documentation of user flows and experiences for the Battlebots …","ref":"/battlebots/rd/user-journeys/","tags":"","title":"User Journeys"},{"body":"Architecture Decision Records (ADRs) This section contains architectural decision records that document the key design choices made for the Battlebots platform. Each ADR follows the MADR 4.0.0 format and includes:\nContext and problem statement Decision drivers and constraints Considered options with pros and cons Decision outcome and rationale Consequences (positive and negative) Confirmation methods ADR Categories ADRs are classified into three categories:\nStrategic - High-level architectural decisions affecting the entire system (frameworks, authentication strategies, cross-cutting patterns). Use for foundational technology choices. User Journey - Decisions solving specific user journey problems. More tactical than strategic, but still architectural. Use when evaluating approaches to implement user-facing features. API Design - API endpoint implementation decisions (pagination, filtering, bulk operations). Use for significant API design trade-offs that warrant documentation. Status Values Each ADR has a status that reflects its current state:\nproposed - Decision is under consideration accepted - Decision has been approved and should be implemented rejected - Decision was considered but not approved deprecated - Decision is no longer relevant or has been superseded superseded by ADR-XXXX - Decision has been replaced by a newer ADR These records provide historical context for architectural decisions and help ensure consistency across the platform.\n","categories":"","description":"Documentation of architectural decisions made in the Battlebots platform using MADR 4.0.0 standard\n","excerpt":"Documentation of architectural decisions made in the Battlebots …","ref":"/battlebots/rd/adrs/","tags":"","title":"Architecture Decision Records"},{"body":"Welcome! Battle Bots is a game in which you, the human, implement an autonomous “bot” to do battle with “bots” implemented by other humans.\nWhat is a Bot? A bot is a independent piece of software which is programmed to battle other bots by reacting to state updates (e.g. bot B moved to point A) and performing its own actions (e.g. fire missile at point A).\n","categories":"","description":"Battle Bots is a PVP game for autonomous players","excerpt":"Battle Bots is a PVP game for autonomous players","ref":"/battlebots/","tags":"","title":"Battle Bots"},{"body":"R\u0026D Process The Research \u0026 Design process follows a structured workflow to ensure comprehensive analysis and documentation of user experiences, technical solutions, and implementation details.\nProcess Steps Document the User Journey\nCreate a user journey document for the specific user experience Include flow diagrams using Mermaid to visualize user interactions Define prioritized technical requirements (P0/P1/P2) Use the /new-user-journey command to create standardized documentation Design the Solution\nCreate an ADR that designs a solution to implement the user journey Identify and document: Additional ADRs needed for specific components APIs that need to be defined User interface flows (mobile, web, etc.) Data flow from user to end systems (database, notification system, etc.) Capture the complete system architecture and integration points Document Component ADRs\nCreate ADRs for specific technical components identified in the solution design Examples: authentication strategy, session management, account linking, data storage Use the /new-adr command to create standardized MADR 4.0.0 format documents Document technical decisions with context, considered options, and consequences Document Required APIs\nFor each API endpoint identified in the solution, create comprehensive API documentation Use the /new-api-doc command to create standardized documentation Include: Request/response schemas Authentication requirements Business logic flows (Mermaid diagrams) Error responses and status codes Example curl requests Document API Implementation\nFor each documented API, create an ADR describing the implementation approach Document technical decisions including: Programming language selection Framework and libraries Architecture patterns Testing strategy Example: ADR-0006 documents the tech stack for API development (z5labs/humus framework) Design User Interface\nCreate UI/UX designs for the user journey Ensure designs align with the documented user flows and API contracts Consider platform-specific requirements (mobile, web, desktop) Documentation Structure The R\u0026D documentation is organized into the following sections:\nUser Journeys - User experience flows with technical requirements ADRs - Architectural Decision Records documenting technical decisions APIs - REST API endpoint documentation with schemas and examples Analysis - Research and analysis of technologies and solutions ","categories":"","description":"","excerpt":"R\u0026D Process The Research \u0026 Design process follows a structured …","ref":"/battlebots/rd/","tags":"","title":"Research \u0026 Design"},{"body":"","categories":"","description":"","excerpt":"","ref":"/battlebots/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/battlebots/tags/","tags":"","title":"Tags"}]