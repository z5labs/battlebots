<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Battle Bots on Battle Bots Documentation</title><link>https://z5labs.github.io/battlebots/</link><description>Recent content in Battle Bots on Battle Bots Documentation</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 09 Dec 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://z5labs.github.io/battlebots/index.xml" rel="self" type="application/rss+xml"/><item><title>[0001] Proof of Concept - 1v1 Battle</title><link>https://z5labs.github.io/battlebots/research_and_development/user-journeys/0001-poc/</link><pubDate>Wed, 03 Dec 2025 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/user-journeys/0001-poc/</guid><description>&lt;h2 id="idea"&gt;Idea&lt;/h2&gt;
&lt;p&gt;This proof of concept demonstrates containerized bots battling each other in a 1v1 match within a 2-dimensional space. To evaluate the optimal architecture for the final BattleBots platform, both a client/server implementation and a peer-to-peer implementation will be completed and compared.&lt;/p&gt;
&lt;h2 id="requirements"&gt;Requirements&lt;/h2&gt;
&lt;h3 id="clientserver-architecture"&gt;Client/Server Architecture&lt;/h3&gt;
&lt;p&gt;Implement a client/server architecture to evaluate its suitability for the final BattleBots platform.&lt;/p&gt;
&lt;h3 id="peer-to-peer-architecture"&gt;Peer-to-Peer Architecture&lt;/h3&gt;
&lt;p&gt;Implement a peer-to-peer architecture to compare against the client/server approach.&lt;/p&gt;</description></item><item><title>[0001] Use MADR for Architecture Decision Records</title><link>https://z5labs.github.io/battlebots/research_and_development/adrs/0001-use-madr-for-architecture-decision-records/</link><pubDate>Sun, 02 Nov 2025 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/adrs/0001-use-madr-for-architecture-decision-records/</guid><description>&lt;!--
ADR Categories:
- strategic: High-level architectural decisions (frameworks, auth strategies, cross-cutting patterns)
- user-journey: Solutions for specific user journey problems (feature implementation approaches)
- api-design: API endpoint design decisions (pagination, filtering, bulk operations)
--&gt;
&lt;h2 id="context-and-problem-statement"&gt;Context and Problem Statement&lt;/h2&gt;
&lt;p&gt;As the project grows, architectural decisions are made that have long-term impacts on the system&amp;rsquo;s design, maintainability, and scalability. Without a structured way to document these decisions, we risk losing the context and rationale behind important choices, making it difficult for current and future team members to understand why certain approaches were taken.&lt;/p&gt;</description></item><item><title>[0002] Observability SDK Selection</title><link>https://z5labs.github.io/battlebots/research_and_development/adrs/0002-observability-sdk-selection/</link><pubDate>Fri, 05 Dec 2025 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/adrs/0002-observability-sdk-selection/</guid><description>&lt;h2 id="context-and-problem-statement"&gt;Context and Problem Statement&lt;/h2&gt;
&lt;p&gt;Battle Bots requires comprehensive observability to monitor game server performance, track bot behavior, debug issues, and visualize battle state in real-time. We need to select an observability SDK that will provide instrumentation for metrics, traces, and logs across our system. The choice will impact vendor lock-in, cost, flexibility, and integration complexity.&lt;/p&gt;
&lt;p&gt;Which observability SDK should we adopt for instrumenting the Battle Bots platform?&lt;/p&gt;
&lt;h2 id="decision-drivers"&gt;Decision Drivers&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Vendor neutrality and ability to switch backends&lt;/li&gt;
&lt;li&gt;Support for metrics, traces, and logs (unified observability)&lt;/li&gt;
&lt;li&gt;Language support (especially for our game server implementation)&lt;/li&gt;
&lt;li&gt;Integration with container environments&lt;/li&gt;
&lt;li&gt;Community adoption and long-term sustainability&lt;/li&gt;
&lt;li&gt;Cost implications (SDK licensing, vendor fees)&lt;/li&gt;
&lt;li&gt;Ease of integration and developer experience&lt;/li&gt;
&lt;li&gt;Performance overhead&lt;/li&gt;
&lt;li&gt;Support for custom attributes and semantic conventions&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="considered-options"&gt;Considered Options&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;OpenTelemetry&lt;/li&gt;
&lt;li&gt;Datadog SDK&lt;/li&gt;
&lt;li&gt;Sentry SDK&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="decision-outcome"&gt;Decision Outcome&lt;/h2&gt;
&lt;p&gt;Chosen option: &lt;strong&gt;OpenTelemetry&lt;/strong&gt;, because it is an open standard that prevents vendor lock-in and aligns with the open-source nature of the Battle Bots project. As a CNCF-graduated project, it provides long-term sustainability and broad industry adoption while maintaining flexibility to switch observability backends without re-instrumentation.&lt;/p&gt;</description></item><item><title>[0003] Observability Stack Architecture</title><link>https://z5labs.github.io/battlebots/research_and_development/adrs/0003-observability-stack-architecture/</link><pubDate>Fri, 05 Dec 2025 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/adrs/0003-observability-stack-architecture/</guid><description>&lt;h2 id="context-and-problem-statement"&gt;Context and Problem Statement&lt;/h2&gt;
&lt;p&gt;Following the decision to adopt OpenTelemetry as our observability SDK (ADR-0002), we need to select the backend components for our observability stack. The stack must handle three distinct observability signals: traces, metrics, and logs. We need to decide on the ingestion mechanism for telemetry data, the storage backends for each signal type, and the visualization layer for unified observability.&lt;/p&gt;
&lt;p&gt;Which combination of ingestion, backend, and visualization components should we deploy for the Battle Bots observability stack?&lt;/p&gt;</description></item><item><title>[0004] Bot to Battle Server Communication Protocol</title><link>https://z5labs.github.io/battlebots/research_and_development/adrs/0004-bot-battle-server-interface/</link><pubDate>Fri, 05 Dec 2025 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/adrs/0004-bot-battle-server-interface/</guid><description>&lt;!--
ADR Categories:
- strategic: High-level architectural decisions (frameworks, auth strategies, cross-cutting patterns)
- user-journey: Solutions for specific user journey problems (feature implementation approaches)
- api-design: API endpoint design decisions (pagination, filtering, bulk operations)
--&gt;
&lt;h2 id="context-and-problem-statement"&gt;Context and Problem Statement&lt;/h2&gt;
&lt;p&gt;The Battle Bots platform requires a communication protocol for bots to interact with the battle server (client/server architecture) or with each other (peer-to-peer architecture). This protocol must support real-time communication while remaining language-agnostic to enable bot development in any programming language.&lt;/p&gt;</description></item><item><title>[0005] BattleBot Universe Topological Properties</title><link>https://z5labs.github.io/battlebots/research_and_development/adrs/0005-battlebot-universe-topological-properties/</link><pubDate>Mon, 08 Dec 2025 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/adrs/0005-battlebot-universe-topological-properties/</guid><description>&lt;!--
ADR Categories:
- strategic: High-level architectural decisions (frameworks, auth strategies, cross-cutting patterns)
- user-journey: Solutions for specific user journey problems (feature implementation approaches)
- api-design: API endpoint design decisions (pagination, filtering, bulk operations)
--&gt;
&lt;h2 id="context-and-problem-statement"&gt;Context and Problem Statement&lt;/h2&gt;
&lt;p&gt;Battle Bots requires a rigorous mathematical foundation for the spatial environment where battles occur. We need to define the topological and geometric properties of the &amp;ldquo;BattleBot Universe&amp;rdquo; that govern all spatial interactions, movement mechanics, collision detection, and distance calculations.&lt;/p&gt;</description></item><item><title>[0006] BattleBot Universe Physics Laws</title><link>https://z5labs.github.io/battlebots/research_and_development/adrs/0006-battlebot-universe-physics-laws/</link><pubDate>Mon, 08 Dec 2025 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/adrs/0006-battlebot-universe-physics-laws/</guid><description>&lt;!--
ADR Categories:
- strategic: High-level architectural decisions (frameworks, auth strategies, cross-cutting patterns)
- user-journey: Solutions for specific user journey problems (feature implementation approaches)
- api-design: API endpoint design decisions (pagination, filtering, bulk operations)
--&gt;
&lt;h2 id="context-and-problem-statement"&gt;Context and Problem Statement&lt;/h2&gt;
&lt;p&gt;The BattleBot Universe requires well-defined physics laws to govern gameplay mechanics. ADR-0005 established the mathematical and spatial foundation (2D Euclidean continuous space, rectangular boundaries, Cartesian coordinates), but did not define the physical forces and interactions that govern how objects move, collide, and behave within that space.&lt;/p&gt;</description></item><item><title>[0007] Bot Movement Mechanics</title><link>https://z5labs.github.io/battlebots/research_and_development/adrs/0007-bot-movement-mechanics/</link><pubDate>Mon, 08 Dec 2025 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/adrs/0007-bot-movement-mechanics/</guid><description>&lt;!--
ADR Categories:
- strategic: High-level architectural decisions (frameworks, auth strategies, cross-cutting patterns)
- user-journey: Solutions for specific user journey problems (feature implementation approaches)
- api-design: API endpoint design decisions (pagination, filtering, bulk operations)
--&gt;
&lt;h2 id="context-and-problem-statement"&gt;Context and Problem Statement&lt;/h2&gt;
&lt;p&gt;The BattleBot Universe requires a clearly defined movement system that specifies &lt;strong&gt;how bots control their movement&lt;/strong&gt; in the 2D battle space. ADR-0005 established the spatial foundation (2D continuous Euclidean space with rectangular boundaries), and ADR-0006 defined the physics laws that govern movement (surface friction, collisions, Mass property). However, neither ADR has explicitly decided the movement mechanics - specifically, what API do bot developers use to move their bot, and how does the game engine translate those commands into position updates?&lt;/p&gt;</description></item><item><title>[0008] Bot Characteristics System</title><link>https://z5labs.github.io/battlebots/research_and_development/adrs/0008-bot-characteristics-system/</link><pubDate>Sun, 07 Dec 2025 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/adrs/0008-bot-characteristics-system/</guid><description>&lt;!--
ADR Categories:
- strategic: High-level architectural decisions (frameworks, auth strategies, cross-cutting patterns)
- user-journey: Solutions for specific user journey problems (feature implementation approaches)
- api-design: API endpoint design decisions (pagination, filtering, bulk operations)
--&gt;
&lt;h2 id="context-and-problem-statement"&gt;Context and Problem Statement&lt;/h2&gt;
&lt;p&gt;Battle Bots requires an attribute system that defines bot capabilities and creates strategic differentiation between different bot builds. We need to determine how many stats, what they represent, how they interact, and how they integrate with equipment customization. The characteristic system must support diverse playstyles while remaining accessible and understandable to bot developers.&lt;/p&gt;</description></item><item><title>[0009] Equipment Type System</title><link>https://z5labs.github.io/battlebots/research_and_development/adrs/0009-equipment-type-system/</link><pubDate>Mon, 08 Dec 2025 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/adrs/0009-equipment-type-system/</guid><description>&lt;!--
ADR Categories:
- strategic: High-level architectural decisions (frameworks, auth strategies, cross-cutting patterns)
- user-journey: Solutions for specific user journey problems (feature implementation approaches)
- api-design: API endpoint design decisions (pagination, filtering, bulk operations)
--&gt;
&lt;h2 id="context-and-problem-statement"&gt;Context and Problem Statement&lt;/h2&gt;
&lt;p&gt;The BattleBot equipment system requires a clearly defined set of &lt;strong&gt;equipment type categories&lt;/strong&gt; that bots can equip to customize their capabilities. ADR-0008 (Bot Characteristics System) established that equipment modifies bot stats—particularly Mass, Health, and Defense—and creates the foundation for equipment-based strategic differentiation. However, we have not yet decided which &lt;strong&gt;types&lt;/strong&gt; of equipment will be supported in the initial implementation.&lt;/p&gt;</description></item><item><title>[0010] Biome Definition Framework</title><link>https://z5labs.github.io/battlebots/research_and_development/adrs/0010-biome-definition-framework/</link><pubDate>Tue, 09 Dec 2025 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/adrs/0010-biome-definition-framework/</guid><description>&lt;!--
ADR Categories:
- strategic: High-level architectural decisions (frameworks, auth strategies, cross-cutting patterns)
- user-journey: Solutions for specific user journey problems (feature implementation approaches)
- api-design: API endpoint design decisions (pagination, filtering, bulk operations)
--&gt;
&lt;h2 id="context-and-problem-statement"&gt;Context and Problem Statement&lt;/h2&gt;
&lt;p&gt;BattleBots requires diverse battle arenas with distinct tactical characteristics to provide meaningful gameplay variety. Currently, the game physics system (ADR-0006) includes variable friction with position-dependent coefficients, explicitly anticipating terrain-based mechanics. To operationalize this capability, we need a consistent framework for defining what makes one arena distinct from another.&lt;/p&gt;</description></item><item><title>Getting Started</title><link>https://z5labs.github.io/battlebots/gameplay/1v1-battles/getting-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/gameplay/1v1-battles/getting-started/</guid><description>&lt;p&gt;This guide will help you create your first bot for 1v1 battles. We&amp;rsquo;ll cover the basics of bot structure, equipment configuration, and connecting to the battle server.&lt;/p&gt;
&lt;h2 id="prerequisites"&gt;Prerequisites&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Programming experience in any language&lt;/li&gt;
&lt;li&gt;Battle Bots SDK installed for your chosen language&lt;/li&gt;
&lt;li&gt;Development environment set up&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="bot-structure"&gt;Bot Structure&lt;/h2&gt;
&lt;p&gt;A Battle Bots bot consists of:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Equipment Configuration&lt;/strong&gt; - Choose your weapon and armor before battle&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;State Processing&lt;/strong&gt; - Receive and process battle state updates each tick&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Action Submission&lt;/strong&gt; - Decide which actions to perform based on current state&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Communication&lt;/strong&gt; - Connect to the battle server via gRPC&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="minimal-bot-example"&gt;Minimal Bot Example&lt;/h2&gt;
&lt;p&gt;Here&amp;rsquo;s a minimal bot structure to get you started:&lt;/p&gt;</description></item><item><title>[0011] 1v1 Battles</title><link>https://z5labs.github.io/battlebots/research_and_development/adrs/0011-1v1-battles/</link><pubDate>Tue, 09 Dec 2025 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/adrs/0011-1v1-battles/</guid><description>&lt;!--
ADR Categories:
- strategic: High-level architectural decisions (frameworks, auth strategies, cross-cutting patterns)
- user-journey: Solutions for specific user journey problems (feature implementation approaches)
- api-design: API endpoint design decisions (pagination, filtering, bulk operations)
--&gt;
&lt;h2 id="context-and-problem-statement"&gt;Context and Problem Statement&lt;/h2&gt;
&lt;p&gt;BattleBot 1v1 battles require a formal definition of what constitutes an arena and how battle instances are configured. Currently, the BattleBot Universe (ADR-0005) defines the universal topological space (R² Euclidean coordinates with Cartesian system) and fixed boundary dimensions ([-50, 50] × [-50, 50]). However, this establishes a single static arena rather than a configurable system that enables tactical variety through property selection.&lt;/p&gt;</description></item><item><title>Arena</title><link>https://z5labs.github.io/battlebots/gameplay/1v1-battles/arena/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/gameplay/1v1-battles/arena/</guid><description>&lt;p&gt;1v1 battles take place in a 2D rectangular arena with defined boundaries. The arena uses a Cartesian coordinate system and applies physics rules for movement, collision, and friction.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;About Arenas&lt;/strong&gt;: A Battle Arena is a configured instance of the BattleBot Universe with specific properties: terrain type (biome), boundary dimensions, visibility rules, starting positions, and win conditions. Different battles may use different arena configurations. For complete technical specification, see &lt;strong&gt;&lt;a href="https://z5labs.github.io/battlebots/research_and_development/adrs/0011-1v1-battles.md"&gt;ADR-0011: 1v1 Battles&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;</description></item><item><title>Bot Characteristics</title><link>https://z5labs.github.io/battlebots/gameplay/1v1-battles/bot-characteristics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/gameplay/1v1-battles/bot-characteristics/</guid><description>&lt;p&gt;Your bot&amp;rsquo;s capabilities are defined by three core characteristics: &lt;strong&gt;Health&lt;/strong&gt;, &lt;strong&gt;Defense&lt;/strong&gt;, and &lt;strong&gt;Mass&lt;/strong&gt;. These stats determine your survivability, damage mitigation, and movement properties.&lt;/p&gt;
&lt;h2 id="health"&gt;Health&lt;/h2&gt;
&lt;p&gt;Health (HP) is your bot&amp;rsquo;s survivability pool - the total amount of damage your bot can sustain before being eliminated.&lt;/p&gt;
&lt;h3 id="key-properties"&gt;Key Properties&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HP Pool&lt;/strong&gt;: Total damage your bot can take before destruction
&lt;ul&gt;
&lt;li&gt;Range: 100-500 HP (placeholder values, subject to balance tuning)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Destruction&lt;/strong&gt;: Bot is eliminated when Health reaches 0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No Regeneration&lt;/strong&gt;: Health does not regenerate during battle (current design)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="gameplay-impact"&gt;Gameplay Impact&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Higher Health allows your bot to stay in battles longer&lt;/li&gt;
&lt;li&gt;Low-Health bots must rely on damage avoidance through mobility or defensive actions&lt;/li&gt;
&lt;li&gt;Health works multiplicatively with Defense to create Effective HP (see below)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="defense"&gt;Defense&lt;/h2&gt;
&lt;p&gt;Defense represents your bot&amp;rsquo;s ability to mitigate incoming damage. It reduces the effective damage from enemy attacks.&lt;/p&gt;</description></item><item><title>Equipment</title><link>https://z5labs.github.io/battlebots/gameplay/1v1-battles/equipment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/gameplay/1v1-battles/equipment/</guid><description>&lt;div class="alert alert-warning" role="alert"&gt;
&lt;h4 class="alert-heading"&gt;Subject to Change&lt;/h4&gt;

 The equipment system described here is currently in the PROPOSED stage and may change based on playtesting and balance analysis. Check back for updates!

&lt;/div&gt;

&lt;p&gt;Before battle, you configure your bot&amp;rsquo;s &lt;strong&gt;loadout&lt;/strong&gt; by selecting equipment. Equipment modifies your bot&amp;rsquo;s characteristics and determines which actions are available during battle.&lt;/p&gt;
&lt;h3 id="loadout-slots"&gt;Loadout Slots&lt;/h3&gt;
&lt;p&gt;Each bot equips:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1 Weapon&lt;/strong&gt; - Determines available combat actions&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1 Armor&lt;/strong&gt; - Modifies Defense and Speed characteristics&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All equipment contributes to your bot&amp;rsquo;s total Mass, which affects movement acceleration.&lt;/p&gt;</description></item><item><title>Actions</title><link>https://z5labs.github.io/battlebots/gameplay/1v1-battles/actions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/gameplay/1v1-battles/actions/</guid><description>&lt;div class="alert alert-warning" role="alert"&gt;
&lt;h4 class="alert-heading"&gt;Subject to Change&lt;/h4&gt;

 The action system described here is currently in the PROPOSED stage and may change based on playtesting and balance analysis. Energy costs, cooldowns, and action availability may be adjusted!

&lt;/div&gt;

&lt;p&gt;During battle, your bot performs &lt;strong&gt;actions&lt;/strong&gt; each tick. Actions allow your bot to move, attack, defend, and gather information. All actions are constrained by a dual-resource system: energy costs and cooldowns.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Physics Integration&lt;/strong&gt;: The Move action implements thrust-based movement governed by physics laws. See &lt;a href="https://z5labs.github.io/battlebots/research_and_development/adrs/0006-battlebot-universe-physics-laws/"&gt;ADR-0006: BattleBot Universe Physics Laws&lt;/a&gt; and &lt;a href="https://z5labs.github.io/battlebots/research_and_development/adrs/0007-bot-movement-mechanics/"&gt;ADR-0007: Bot Movement Mechanics&lt;/a&gt; for detailed specifications.&lt;/p&gt;</description></item><item><title>Loki: OTLP Integration</title><link>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/logs/loki/loki-otlp-integration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/logs/loki/loki-otlp-integration/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;Grafana Loki introduced native OpenTelemetry Protocol (OTLP) support in version 3.0, marking a significant advancement in how logs can be ingested into Loki. This native integration allows applications instrumented with OpenTelemetry to send logs directly to Loki using the standardized OTLP format, eliminating the need for format transformations and simplifying the observability pipeline.&lt;/p&gt;
&lt;p&gt;The native OTLP endpoint provides a fully OpenTelemetry-compliant ingestion path where logs sent in OTLP format are stored directly in Loki without requiring conversion to JSON or logfmt blobs. This approach leverages Loki&amp;rsquo;s structured metadata feature, which stores log attributes and other OpenTelemetry LogRecord fields separately from the log body itself. The result is a more intuitive query experience and better performance, as queries no longer need to parse JSON at runtime to access fields.&lt;/p&gt;</description></item><item><title>Loki: Overview</title><link>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/logs/loki/loki-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/logs/loki/loki-overview/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;Grafana Loki is a horizontally-scalable, highly-available, multi-tenant log aggregation system designed to be cost-effective and easy to operate. Inspired by Prometheus, Loki takes a fundamentally different approach to log storage compared to traditional systems like Elasticsearch.&lt;/p&gt;
&lt;p&gt;The core innovation of Loki is its index-free architecture: instead of indexing the full contents of log lines, Loki only indexes metadata labels for each log stream. This design dramatically reduces storage costs, memory requirements, and operational complexity while still enabling fast queries through label-based filtering and grep-style text search.&lt;/p&gt;</description></item><item><title>Mimir: OTLP and OpenTelemetry Collector Integration</title><link>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/metrics/mimir/mimir-otlp-integration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/metrics/mimir/mimir-otlp-integration/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;This document provides comprehensive guidance on integrating Grafana Mimir with the OpenTelemetry Collector, addressing two critical questions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Does Mimir work with OTLP?&lt;/strong&gt; → &lt;strong&gt;YES&lt;/strong&gt; - Native OTLP ingestion since version 2.3.0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Can it be integrated with the OTel Collector?&lt;/strong&gt; → &lt;strong&gt;YES&lt;/strong&gt; - Full integration via &lt;code&gt;otlphttp&lt;/code&gt; or &lt;code&gt;prometheusremotewrite&lt;/code&gt; exporters&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The integration enables a vendor-neutral observability pipeline where the OpenTelemetry Collector collects metrics from instrumented applications and forwards them to Mimir for long-term storage, querying, and alerting.&lt;/p&gt;</description></item><item><title>Mimir: Overview and Architecture</title><link>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/metrics/mimir/mimir-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/metrics/mimir/mimir-overview/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;Grafana Mimir is a horizontally scalable, highly available, multi-tenant, long-term storage solution for Prometheus metrics. It transforms Prometheus&amp;rsquo;s single-server architecture into a distributed microservices platform capable of handling over 1 billion active time series with unlimited retention backed by object storage.&lt;/p&gt;
&lt;h3 id="what-is-mimir"&gt;What is Mimir?&lt;/h3&gt;
&lt;p&gt;Mimir takes the Prometheus Time Series Database (TSDB) and &lt;strong&gt;splits it into microservices&lt;/strong&gt;, creating a distributed system where each component can scale independently. While Prometheus excels at real-time monitoring on a single machine, Mimir extends this capability to enterprise scale with:&lt;/p&gt;</description></item><item><title>OpenTelemetry Collector Overview</title><link>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/otel-collector/opentelemetry-collector-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/otel-collector/opentelemetry-collector-overview/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;The OpenTelemetry Collector is a vendor-agnostic application that receives, processes, and exports telemetry data (traces, metrics, and logs). It serves as a centralized component in observability architectures, removing the need to run multiple agents or collectors for different telemetry formats and backends.&lt;/p&gt;
&lt;p&gt;The Collector supports open-source observability data formats including Jaeger, Prometheus, Fluent Bit, and others, while providing a unified approach to telemetry handling. It enables services to offload telemetry data quickly while the Collector handles retries, batching, encryption, and sensitive data filtering.&lt;/p&gt;</description></item><item><title>OpenTelemetry Collector: Logs Support</title><link>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/otel-collector/otel-collector-logs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/otel-collector/otel-collector-logs/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;The OpenTelemetry Collector provides comprehensive support for collecting, processing, and exporting log data from various sources to multiple backends. Unlike traditional logging agents that focus on specific formats or destinations, the Collector treats logs as first-class observability signals alongside metrics and traces.&lt;/p&gt;
&lt;p&gt;The Collector&amp;rsquo;s log support enables correlation between logs and traces through shared execution context (TraceId and SpanId), allowing unified observability across all three signal types. This correlation is particularly valuable for debugging complex distributed systems where understanding both the quantitative measurements and the detailed event context is essential.&lt;/p&gt;</description></item><item><title>OpenTelemetry Collector: Metrics Support</title><link>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/otel-collector/otel-collector-metrics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/otel-collector/otel-collector-metrics/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;The OpenTelemetry Collector provides comprehensive support for collecting, processing, and exporting metrics data from diverse sources to multiple backends. It serves as a bridge between different metrics ecosystems, enabling seamless integration of Prometheus metrics, host system metrics, and custom application metrics within a unified observability platform.&lt;/p&gt;
&lt;p&gt;The Collector&amp;rsquo;s metrics support emphasizes signal correlation—connecting metrics to traces through exemplars and enriching attributes via Baggage and Context. This enables powerful observability patterns such as jumping from a metric anomaly to related traces or finding metrics that explain slow trace spans.&lt;/p&gt;</description></item><item><title>OpenTelemetry Collector: Self-Monitoring</title><link>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/otel-collector/otel-collector-self-monitoring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/otel-collector/otel-collector-self-monitoring/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;The OpenTelemetry Collector is designed as an observable service itself, following the principle that observability infrastructure must be observable. The Collector exposes its own telemetry (metrics, logs, and optionally traces) to enable monitoring health, diagnosing issues, and optimizing performance.&lt;/p&gt;
&lt;p&gt;Self-monitoring is critical for production deployments—without visibility into the Collector&amp;rsquo;s operation, data loss or performance degradation can go undetected. The Collector provides built-in telemetry, diagnostic extensions, and debugging capabilities to ensure reliable operation at scale.&lt;/p&gt;</description></item><item><title>OpenTelemetry Collector: Traces Support</title><link>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/otel-collector/otel-collector-traces/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/otel-collector/otel-collector-traces/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;The OpenTelemetry Collector provides comprehensive support for distributed tracing, enabling collection, processing, and export of trace data from multiple sources to various backend systems. Distributed tracing tracks requests as they flow through distributed systems, providing visibility into service interactions, latency bottlenecks, and error propagation paths.&lt;/p&gt;
&lt;p&gt;The Collector acts as a central hub for trace data, accepting traces in multiple formats (OTLP, Jaeger, Zipkin), performing intelligent sampling decisions, and routing to multiple tracing backends simultaneously. This unified approach simplifies observability infrastructure while preserving the ability to use best-of-breed tools for different use cases.&lt;/p&gt;</description></item><item><title>Tempo: OTLP and OpenTelemetry Collector Integration</title><link>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/traces/tempo/tempo-otlp-integration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/traces/tempo/tempo-otlp-integration/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;This document provides comprehensive guidance on integrating Grafana Tempo with the OpenTelemetry Collector, addressing two critical questions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Does Tempo support OTLP?&lt;/strong&gt; → &lt;strong&gt;YES&lt;/strong&gt; - Native OTLP ingestion since version 1.3.0 (January 2022)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Can the OTel Collector export to Tempo?&lt;/strong&gt; → &lt;strong&gt;YES&lt;/strong&gt; - Full integration via &lt;code&gt;otlp&lt;/code&gt; (gRPC) or &lt;code&gt;otlphttp&lt;/code&gt; (HTTP) exporters&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The integration enables a vendor-neutral observability pipeline where the OpenTelemetry Collector collects traces from instrumented applications and forwards them to Tempo for cost-effective, long-term trace storage, querying with TraceQL, and correlation with metrics and logs.&lt;/p&gt;</description></item><item><title>Tempo: Overview</title><link>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/traces/tempo/tempo-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://z5labs.github.io/battlebots/research_and_development/analysis/observability/traces/tempo/tempo-overview/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;Grafana Tempo is a high-volume, minimal dependency distributed tracing backend designed for cost-efficiency and operational simplicity. Unlike traditional distributed tracing systems that require complex database infrastructure like Cassandra or Elasticsearch, Tempo leverages object storage as its only dependency, dramatically reducing operational complexity while providing powerful trace querying capabilities through TraceQL.&lt;/p&gt;
&lt;p&gt;The core innovation of Tempo is its index-free, object storage-first architecture: traces are stored as immutable blocks in cost-effective object storage (S3, GCS, Azure, MinIO) without requiring expensive indexing infrastructure. While this trades off some search flexibility compared to fully-indexed systems like Jaeger, it enables storing 100% of traces at a fraction of the cost. TraceQL, Tempo&amp;rsquo;s SQL-like query language, provides sophisticated trace analysis capabilities including filtering by span attributes, duration thresholds, and span relationships.&lt;/p&gt;</description></item></channel></rss>